<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Doyle Spiral Studio</title>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <style>
    :root {
      color-scheme: light dark;
      font-family: "Inter", "Segoe UI", system-ui, sans-serif;
      --page-bg: radial-gradient(circle at 20% -10%, #bae6fd, #dbeafe 40%, #e2e8f0 85%);
      --panel-bg: rgba(255, 255, 255, 0.86);
      --panel-border: rgba(148, 163, 184, 0.24);
      --text-strong: #0f172a;
      --text-muted: #64748b;
      --accent: #2563eb;
      --accent-soft: rgba(37, 99, 235, 0.12);
      --danger: #b91c1c;
      background: var(--page-bg);
      min-height: 100%;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      display: flex;
      justify-content: center;
      padding: 2.5rem clamp(1rem, 3vw, 2.5rem);
      color: var(--text-strong);
    }

    .app-shell {
      width: min(1200px, 100%);
      display: grid;
      gap: 2rem;
    }

    header {
      display: flex;
      flex-direction: column;
      gap: 0.65rem;
    }

    header h1 {
      font-size: clamp(2rem, 4vw, 2.8rem);
      letter-spacing: -0.03em;
    }

    header p {
      color: var(--text-muted);
      max-width: 65ch;
      line-height: 1.6;
    }

    .layout {
      display: grid;
      gap: 2rem;
      grid-template-columns: minmax(320px, 360px) 1fr;
    }

    .panel {
      background: var(--panel-bg);
      border-radius: 1.5rem;
      padding: 1.8rem;
      border: 1px solid var(--panel-border);
      box-shadow: 0 25px 45px rgba(15, 23, 42, 0.12);
      backdrop-filter: blur(18px);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    form {
      display: grid;
      gap: 1.25rem;
    }

    .field-group {
      display: grid;
      gap: 0.6rem;
    }

    label {
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      font-weight: 600;
    }

    input[type="number"],
    select {
      width: 100%;
      padding: 0.75rem 0.9rem;
      border-radius: 0.9rem;
      border: 1px solid rgba(148, 163, 184, 0.3);
      font-size: 0.95rem;
      background: rgba(255, 255, 255, 0.9);
      color: var(--text-strong);
    }

    input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
    }

    .inline-fields {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 1rem;
    }

    .checkbox-row {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .checkbox-row label {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.45rem 0.75rem;
      border-radius: 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.3);
      text-transform: none;
      letter-spacing: 0.01em;
      font-size: 0.85rem;
      color: var(--text-muted);
      font-weight: 500;
      background: rgba(255, 255, 255, 0.6);
    }

    .checkbox-row input {
      width: 1rem;
      height: 1rem;
    }

    .fill-settings {
      display: grid;
      gap: 1rem;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    }

    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    button {
      appearance: none;
      border: none;
      border-radius: 0.9rem;
      padding: 0.9rem 1.3rem;
      font-size: 0.95rem;
      font-weight: 600;
      letter-spacing: -0.01em;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
      background: var(--accent);
      color: white;
      box-shadow: 0 18px 30px rgba(37, 99, 235, 0.22);
    }

    button.secondary {
      background: rgba(148, 163, 184, 0.16);
      color: var(--text-strong);
      box-shadow: none;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px);
    }

    .status {
      padding: 0.75rem 1rem;
      border-radius: 0.85rem;
      font-size: 0.85rem;
      background: rgba(148, 163, 184, 0.14);
      color: var(--text-muted);
    }

    .status.loading {
      background: rgba(37, 99, 235, 0.12);
      color: var(--accent);
    }

    .status.error {
      background: rgba(220, 38, 38, 0.16);
      color: var(--danger);
    }

    .preview {
      position: relative;
      display: grid;
      gap: 1.25rem;
    }

    .view-toggle {
      display: inline-flex;
      background: rgba(255, 255, 255, 0.78);
      border-radius: 999px;
      padding: 0.25rem;
      border: 1px solid rgba(148, 163, 184, 0.3);
      box-shadow: 0 18px 30px rgba(15, 23, 42, 0.1);
      width: fit-content;
    }

    .view-toggle button {
      background: transparent;
      box-shadow: none;
      color: var(--text-muted);
      padding: 0.55rem 1.15rem;
      font-size: 0.9rem;
    }

    .view-toggle button.active {
      background: var(--accent);
      color: white;
      box-shadow: 0 12px 24px rgba(37, 99, 235, 0.3);
    }

    [hidden] {
      display: none !important;
    }

    .preview-card {
      background: var(--panel-bg);
      border-radius: 1.5rem;
      border: 1px solid var(--panel-border);
      min-height: 520px;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      justify-content: center;
      box-shadow: 0 25px 45px rgba(15, 23, 42, 0.1);
      overflow: hidden;
      position: relative;
    }

    #svgPreview svg {
      width: 100%;
      height: 100%;
    }

    .empty-state {
      text-align: center;
      color: var(--text-muted);
      padding: 3rem;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 1rem;
    }

    .stat-card {
      background: rgba(255, 255, 255, 0.65);
      border-radius: 1rem;
      padding: 0.9rem 1.2rem;
      border: 1px solid rgba(148, 163, 184, 0.2);
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .stat-card strong {
      display: block;
      color: var(--text-strong);
      font-size: 1.1rem;
      margin-bottom: 0.15rem;
    }

    .three-card {
      padding: 1.5rem;
      gap: 1.25rem;
    }

    .three-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .three-top button {
      padding: 0.7rem 1.1rem;
      font-size: 0.85rem;
    }

    .three-stage {
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(240px, 280px);
      gap: 1.5rem;
      align-items: stretch;
    }

    .three-stage.collapsed {
      grid-template-columns: minmax(0, 1fr);
    }

    .three-stage.collapsed .three-settings {
      display: none;
    }

    #threeCanvas {
      width: 100%;
      height: clamp(420px, 60vh, 620px);
      display: block;
      background: linear-gradient(160deg, rgba(15, 23, 42, 0.94), rgba(30, 41, 59, 0.88));
      border-radius: 1.25rem;
      cursor: grab;
    }

    #threeCanvas:active {
      cursor: grabbing;
    }

    .three-settings {
      background: rgba(248, 250, 252, 0.88);
      border-radius: 1.25rem;
      border: 1px solid rgba(148, 163, 184, 0.25);
      padding: 1.2rem 1.4rem;
      display: grid;
      gap: 1.1rem;
    }

    .three-settings h2 {
      font-size: 0.9rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .three-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 1rem;
    }

    .three-settings label {
      font-size: 0.72rem;
      margin-bottom: 0.35rem;
    }

    .range-value {
      margin-top: 0.3rem;
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .three-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.6rem;
    }

    .three-actions button {
      font-size: 0.85rem;
      padding: 0.7rem 1rem;
    }

    .pulse {
      animation: pulse 1.2s ease;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0.45); }
      70% { box-shadow: 0 0 0 12px rgba(37, 99, 235, 0); }
      100% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0); }
    }

    .three-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 1rem;
    }

    .three-stats .stat-card {
      background: rgba(255, 255, 255, 0.7);
    }

    @media (max-width: 980px) {
      .layout {
        grid-template-columns: 1fr;
      }
      .panel {
        order: 2;
      }
      .preview {
        order: 1;
      }
      .three-stage {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 720px) {
      body {
        padding: 1.6rem 1rem 2.4rem;
      }
      .panel {
        padding: 1.4rem;
      }
      .preview-card {
        padding: 1.2rem;
      }
      .three-top button {
        width: 100%;
      }
      .three-top {
        flex-direction: column;
        align-items: stretch;
      }
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <header>
      <h1>Doyle Spiral Studio</h1>
      <p>Generate Doyle spirals with the native Python geometry engine and preview the results instantly. Switch between the SVG composition and the immersive 3D extrusion without leaving the page.</p>
    </header>

    <div class="layout">
      <section class="panel">
        <form id="controlsForm">
          <div class="inline-fields">
            <div class="field-group">
              <label for="inputP">P (families)</label>
              <input id="inputP" name="p" type="number" min="2" max="128" step="1" value="16" required />
            </div>
            <div class="field-group">
              <label for="inputQ">Q (circles)</label>
              <input id="inputQ" name="q" type="number" min="2" max="256" step="1" value="16" required />
            </div>
          </div>

          <div class="field-group">
            <label for="inputT">T (phase)</label>
            <input id="inputT" name="t" type="range" min="0" max="1" step="0.02" value="0" />
            <div class="status" id="tValue">0.00</div>
          </div>

          <div class="inline-fields">
            <div class="field-group">
              <label for="modeSelect">2D mode</label>
              <select id="modeSelect" name="mode">
                <option value="arram_boyle" selected>Arram-Boyle arcs</option>
                <option value="doyle">Classic circles</option>
              </select>
            </div>
            <div class="field-group">
              <label for="arcModeSelect">Arc selection</label>
              <select id="arcModeSelect" name="arc_mode">
                <option value="closest">Closest</option>
                <option value="farthest">Farthest</option>
                <option value="alternating">Alternating</option>
                <option value="all">All arcs</option>
                <option value="random">Randomised</option>
                <option value="symmetric">Symmetric</option>
                <option value="angular">Angular</option>
              </select>
            </div>
          </div>

          <div class="inline-fields">
            <div class="field-group">
              <label for="numGaps">Gaps</label>
              <input id="numGaps" name="num_gaps" type="number" min="0" max="8" value="2" />
            </div>
            <div class="field-group">
              <label for="svgSize">Canvas size</label>
              <input id="svgSize" name="size" type="number" min="200" max="1600" step="50" value="800" />
            </div>
          </div>

          <div class="checkbox-row">
            <label><input type="checkbox" name="add_fill_pattern" id="togglePattern"> Pattern fill</label>
            <label><input type="checkbox" name="draw_group_outline" id="toggleOutline" checked> Group outline</label>
            <label><input type="checkbox" name="red_outline" id="toggleRed"> Highlight rim</label>
          </div>

          <div class="fill-settings" id="fillSettings" hidden>
            <div class="field-group">
              <label for="fillSpacing">Line spacing</label>
              <input id="fillSpacing" name="fill_pattern_spacing" type="number" min="0.5" step="0.5" value="5" />
            </div>
            <div class="field-group">
              <label for="fillAngle">Angle shift</label>
              <input id="fillAngle" name="fill_pattern_angle" type="number" min="-180" max="180" step="1" value="0" />
            </div>
            <div class="field-group">
              <label for="fillOffset">Inset</label>
              <input id="fillOffset" name="fill_pattern_offset" type="number" min="0" step="0.5" value="0" />
            </div>
          </div>

          <div class="status" id="statusMessage">Adjust parameters and the spiral will render automatically.</div>

          <div class="actions">
            <button type="submit" id="renderButton">Refresh preview</button>
          </div>
        </form>
      </section>

      <section class="preview">
        <div class="view-toggle" role="group" aria-label="Preview mode">
          <button type="button" class="active" data-view="2d" aria-pressed="true">2D SVG</button>
          <button type="button" data-view="3d" aria-pressed="false">3D View</button>
        </div>

        <div class="preview-card" id="view2d">
          <div id="svgPreview" class="empty-state">Rendering spiral…</div>
        </div>

        <div class="stats" id="stats" hidden>
          <div class="stat-card"><strong id="statArcGroups">0</strong>Arc groups</div>
          <div class="stat-card"><strong id="statPolygons">0</strong>Polygons extruded</div>
          <div class="stat-card"><strong id="statMode">Arram-Boyle</strong>Render mode</div>
        </div>

        <div class="preview-card three-card" id="view3d" hidden>
          <div class="three-top">
            <div class="status" id="threeStatus">Switch to the 3D view to load geometry.</div>
            <button type="button" class="secondary" id="threeSettingsToggle" aria-expanded="true">Hide 3D settings</button>
          </div>
          <div class="three-stage" id="threeStage">
            <canvas id="threeCanvas"></canvas>
            <aside class="three-settings" id="threeSettings">
              <h2>3D Settings</h2>
              <div class="three-grid">
                <div>
                  <label for="threeRotationSpeed">Rotation Speed</label>
                  <input type="range" id="threeRotationSpeed" min="0" max="2" step="0.05" value="0.4">
                  <div class="range-value"><span id="threeRotationSpeedValue">0.40</span> revolutions / sec</div>
                </div>
                <div>
                  <label for="threePulseSpeed">Pulse Speed</label>
                  <input type="range" id="threePulseSpeed" min="0.5" max="5" step="0.1" value="2.0">
                  <div class="range-value"><span id="threePulseSpeedValue">2.0</span> pulses / sec</div>
                </div>
                <div>
                  <label for="threeMetalness">Metalness</label>
                  <input type="range" id="threeMetalness" min="0" max="1" step="0.05" value="0.85">
                  <div class="range-value"><span id="threeMetalnessValue">0.85</span></div>
                </div>
                <div>
                  <label for="threeRoughness">Roughness</label>
                  <input type="range" id="threeRoughness" min="0" max="1" step="0.05" value="0.25">
                  <div class="range-value"><span id="threeRoughnessValue">0.25</span></div>
                </div>
              </div>
              <div>
                <label for="threeManualRotation">Manual Rotation</label>
                <input type="range" id="threeManualRotation" min="0" max="360" step="1" value="0">
                <div class="range-value"><span id="threeManualRotationValue">0</span>°</div>
              </div>
              <div class="three-actions">
                <button type="button" id="threeReloadGeometry">Reload geometry</button>
                <button type="button" class="secondary" id="threeLoadJson">Open local JSON</button>
                <button type="button" class="secondary" id="threeResetCamera">Reset view</button>
              </div>
            </aside>
          </div>
          <div class="three-stats" id="threeStats" hidden>
            <div class="stat-card"><strong id="threeStatArcGroups">0</strong>Arc groups</div>
            <div class="stat-card"><strong id="threeStatPolygons">0</strong>Polygons extruded</div>
            <div class="stat-card"><strong id="threeStatParameters">–</strong>Parameters</div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <input type="file" id="threeFileInput" accept="application/json" hidden />

  <script>
  (() => {
    'use strict';

    const TWO_PI = Math.PI * 2;

    function complex(re, im = 0) {
      return { re, im };
    }

    function cloneComplex(z) {
      return { re: z.re, im: z.im };
    }

    function addComplex(a, b) {
      return { re: a.re + b.re, im: a.im + b.im };
    }

    function subComplex(a, b) {
      return { re: a.re - b.re, im: a.im - b.im };
    }

    function mulComplex(a, b) {
      return { re: a.re * b.re - a.im * b.im, im: a.re * b.im + a.im * b.re };
    }

    function mulComplexScalar(a, s) {
      return { re: a.re * s, im: a.im * s };
    }

    function divComplex(a, b) {
      const denom = b.re * b.re + b.im * b.im;
      return {
        re: (a.re * b.re + a.im * b.im) / denom,
        im: (a.im * b.re - a.re * b.im) / denom,
      };
    }

    function absComplex(a) {
      return Math.hypot(a.re, a.im);
    }

    function argComplex(a) {
      return Math.atan2(a.im, a.re);
    }

    function expi(theta) {
      return { re: Math.cos(theta), im: Math.sin(theta) };
    }

    function distanceComplex(a, b) {
      return Math.hypot(a.re - b.re, a.im - b.im);
    }

    function normalizeAngle(angle) {
      let result = angle % TWO_PI;
      if (result <= -Math.PI) {
        result += TWO_PI;
      } else if (result > Math.PI) {
        result -= TWO_PI;
      }
      return result;
    }

    function midpointComplex(a, b) {
      return { re: (a.re + b.re) / 2, im: (a.im + b.im) / 2 };
    }

    function seededRandom(seed) {
      let x = Math.sin(seed) * 10000;
      return () => {
        x = Math.sin(x) * 10000;
        return x - Math.floor(x);
      };
    }

    class CircleElement {
      static _idCounter = 0;

      constructor(center, radius, visible = true) {
        this.center = center;
        this.radius = radius;
        this.visible = visible;
        this.id = ++CircleElement._idCounter;
        this.intersections = [];
        this.neighbours = new Set();
        this._intersectionMap = new Map();
      }

      resetIntersections() {
        this.intersections = [];
        this.neighbours.clear();
        this._intersectionMap.clear();
      }

      addIntersection(point, other, tol = 1e-6) {
        const key = `${point.re.toFixed(6)},${point.im.toFixed(6)}`;
        if (this._intersectionMap.has(key)) {
          return;
        }
        this._intersectionMap.set(key, true);
        this.intersections.push({ point, circle: other });
        this.neighbours.add(other);
      }

      getIntersectionPoints(other, tol = 1e-6) {
        const d = distanceComplex(this.center, other.center);
        const r1 = this.radius;
        const r2 = other.radius;
        if (d > r1 + r2 + tol || d < Math.abs(r1 - r2) - tol || d < tol) {
          return [];
        }
        const a = (r1 * r1 - r2 * r2 + d * d) / (2 * d);
        const hSq = r1 * r1 - a * a;
        if (hSq < -tol) {
          return [];
        }
        const h = Math.sqrt(Math.max(hSq, 0));
        const diff = subComplex(other.center, this.center);
        const mid = addComplex(this.center, mulComplexScalar(diff, a / d));
        const perp = mulComplexScalar({ re: -diff.im, im: diff.re }, 1 / d);
        const p1 = addComplex(mid, mulComplexScalar(perp, h));
        const p2 = subComplex(mid, mulComplexScalar(perp, h));
        if (h < tol) {
          return [p1];
        }
        return [p1, p2];
      }

      finalizeIntersections(reference = complex(0, 0)) {
        if (!this.intersections.length) {
          return;
        }
        const center = this.center;
        const startIndex = this.intersections.reduce((bestIdx, entry, idx) => {
          const best = this.intersections[bestIdx];
          const dBest = distanceComplex(best.point, reference);
          const dCurr = distanceComplex(entry.point, reference);
          return dCurr < dBest ? idx : bestIdx;
        }, 0);
        const startPoint = this.intersections[startIndex].point;
        const startAngle = argComplex(subComplex(startPoint, center));

        const clockwiseOffset = (angle) => {
          const offset = (startAngle - angle) % TWO_PI;
          return offset < 0 ? offset + TWO_PI : offset;
        };

        this.intersections.sort((a, b) => {
          const angleA = argComplex(subComplex(a.point, center));
          const angleB = argComplex(subComplex(b.point, center));
          return clockwiseOffset(angleA) - clockwiseOffset(angleB);
        });
      }
    }

    class ArcElement {
      constructor(circle, start, end, steps = 40, visible = true) {
        this.circle = circle;
        this.start = start;
        this.end = end;
        this.steps = Math.max(2, steps);
        this.visible = visible;
        this._pointsCache = null;
      }

      getCachedPoints() {
        return this._pointsCache;
      }

      getPoints() {
        if (this._pointsCache) {
          return this._pointsCache;
        }
        const c = this.circle.center;
        const r = this.circle.radius;
        const a1 = argComplex(subComplex(this.start, c));
        const a2 = argComplex(subComplex(this.end, c));
        let delta = (a2 - a1 + TWO_PI) % TWO_PI;
        if (delta > Math.PI) {
          delta -= TWO_PI;
        }
        const points = [];
        for (let i = 0; i < this.steps; i += 1) {
          const t = this.steps === 1 ? 0 : i / (this.steps - 1);
          const angle = a1 + delta * t;
          const exp = { re: Math.cos(angle), im: Math.sin(angle) };
          points.push(addComplex(c, mulComplexScalar(exp, r)));
        }
        this._pointsCache = points;
        return points;
      }
    }

    class ArcGroup {
      static _idCounter = 0;

      constructor(name = null) {
        this.id = ++ArcGroup._idCounter;
        this.name = name || `arcgroup_${this.id}`;
        this.arcs = [];
        this._arcPointsCache = new Map();
        this._outlineCache = null;
        this.debug_fill = null;
        this.debug_stroke = null;
        this.ring_index = null;
      }

      addArc(arc) {
        this.arcs.push(arc);
        this._cacheArcPoints(arc);
        this._outlineCache = null;
      }

      _cacheArcPoints(arc) {
        let points = arc.getCachedPoints();
        if (!points) {
          points = arc.getPoints();
        }
        this._arcPointsCache.set(arc, points);
        return points;
      }

      _ensureArcPoints(arc) {
        let cached = this._arcPointsCache.get(arc);
        const current = arc.getCachedPoints() || arc.getPoints();
        if (cached !== current) {
          cached = current;
          this._arcPointsCache.set(arc, cached);
          this._outlineCache = null;
        }
        return cached;
      }

      _matchPoints(a, b, tol = 1e-6) {
        return distanceComplex(a, b) <= tol;
      }

      _tryAttachArc(ordered, pts, tol) {
        const startExisting = ordered[0];
        const endExisting = ordered[ordered.length - 1];
        const startArc = pts[0];
        const endArc = pts[pts.length - 1];

        if (this._matchPoints(endExisting, startArc, tol)) {
          return ordered.concat(pts.slice(1).map(cloneComplex));
        }
        if (this._matchPoints(endExisting, endArc, tol)) {
          const rev = pts.slice().reverse().map(cloneComplex);
          return ordered.concat(rev.slice(1));
        }
        if (this._matchPoints(startExisting, endArc, tol)) {
          return pts.slice(0, -1).map(cloneComplex).concat(ordered);
        }
        if (this._matchPoints(startExisting, startArc, tol)) {
          const rev = pts.slice().reverse().map(cloneComplex);
          return rev.slice(0, -1).concat(ordered);
        }
        return null;
      }

      _attachByProximity(ordered, pts) {
        const front = ordered[0];
        const back = ordered[ordered.length - 1];
        const dFront = Math.min(distanceComplex(pts[0], front), distanceComplex(pts[pts.length - 1], front));
        const dBack = Math.min(distanceComplex(pts[0], back), distanceComplex(pts[pts.length - 1], back));

        if (dFront < dBack) {
          if (distanceComplex(pts[pts.length - 1], front) <= distanceComplex(pts[0], front)) {
            return pts.slice(0, -1).map(cloneComplex).concat(ordered);
          }
          return pts.slice().reverse().slice(0, -1).map(cloneComplex).concat(ordered);
        }
        if (distanceComplex(pts[0], back) <= distanceComplex(pts[pts.length - 1], back)) {
          return ordered.concat(pts.slice(1).map(cloneComplex));
        }
        return ordered.concat(pts.slice().reverse().slice(1).map(cloneComplex));
      }

      getClosedOutline(tol = 1e-3) {
        if (this._outlineCache) {
          return this._outlineCache.map(cloneComplex);
        }
        if (!this.arcs.length) {
          return [];
        }
        const entries = this.arcs.map(arc => [arc, this._ensureArcPoints(arc)]);
        entries.sort((a, b) => b[1].length - a[1].length);

        let ordered = entries[0][1].map(cloneComplex);
        const used = new Set([0]);

        while (true) {
          let attached = false;
          for (let idx = 0; idx < entries.length; idx += 1) {
            if (used.has(idx)) {
              continue;
            }
            const candidate = this._tryAttachArc(ordered, entries[idx][1], tol);
            if (candidate) {
              ordered = candidate;
              used.add(idx);
              attached = true;
              break;
            }
          }
          if (!attached) {
            break;
          }
        }

        for (let idx = 0; idx < entries.length; idx += 1) {
          if (!used.has(idx)) {
            ordered = this._attachByProximity(ordered, entries[idx][1]);
          }
        }

        if (ordered.length && distanceComplex(ordered[0], ordered[ordered.length - 1]) <= tol) {
          ordered[ordered.length - 1] = cloneComplex(ordered[0]);
        }

        this._outlineCache = ordered.map(cloneComplex);
        return this._outlineCache.map(cloneComplex);
      }

      toSvgFill(context, {
        debug = false,
        fillOpacity = 0.25,
        patternFill = false,
        lineSettings = [3, 0],
        drawOutline = true,
      } = {}) {
        const outline = this.getClosedOutline();
        if (!outline.length) {
          return;
        }

        if (debug) {
          const fill = this.debug_fill || context.randomColorForId(this.id);
          const stroke = this.debug_stroke || '#000000';
          context.drawGroupOutline(outline, {
            fill,
            stroke,
            strokeWidth: 0.8,
            fillOpacity,
          });
          return;
        }

        if (patternFill) {
          const stroke = this.debug_stroke || '#000000';
          context.drawGroupOutline(outline, {
            stroke: drawOutline ? stroke : 'none',
            strokeWidth: drawOutline ? 0.8 : 0,
            fillPattern: {
              spacing: lineSettings[0],
              angle: lineSettings[1],
              color: stroke,
              strokeWidth: 0.6,
              opacity: 0.6,
            },
            fillOpacity,
          });
        } else if (drawOutline) {
          const stroke = this.debug_stroke || '#000000';
          context.drawGroupOutline(outline, {
            stroke,
            strokeWidth: 0.8,
            fill: 'none',
          });
        }
      }
    }

    class DrawingContext {
      constructor(size = 800) {
        this.size = size;
        this.scaleFactor = 1;
        this.viewBox = [-size / 2, -size / 2, size, size];
        this.elements = [];
        this.defs = [];
        this.patternCount = 0;
      }

      setNormalizationScale(circles) {
        if (!circles.length) {
          this.scaleFactor = 1;
          return;
        }
        let maxExtent = 1;
        for (const circle of circles) {
          const cx = circle.center.re;
          const cy = circle.center.im;
          const r = circle.radius;
          maxExtent = Math.max(maxExtent, Math.abs(cx) + r, Math.abs(cy) + r);
        }
        this.scaleFactor = (this.size / 2.1) / maxExtent;
      }

      randomColorForId(id) {
        const rand = seededRandom(id * 97 + 13);
        const r = Math.floor(rand() * 200 + 40);
        const g = Math.floor(rand() * 200 + 40);
        const b = Math.floor(rand() * 200 + 40);
        return `rgb(${r}, ${g}, ${b})`;
      }

      drawCircle(circle, { fill = '#4CB39B', opacity = 0.8 } = {}) {
        if (!circle.visible) {
          return;
        }
        const scaled = mulComplexScalar(circle.center, this.scaleFactor);
        const radius = circle.radius * this.scaleFactor;
        this.elements.push(`<circle cx="${scaled.re.toFixed(4)}" cy="${scaled.im.toFixed(4)}" r="${radius.toFixed(4)}" fill="${fill}" fill-opacity="${opacity}" />`);
      }

      drawArc(arc, { color = '#0f172a', width = 1.0 } = {}) {
        if (!arc.visible) {
          return;
        }
        const pts = arc.getCachedPoints() || arc.getPoints();
        if (!pts.length) {
          return;
        }
        const scaled = pts.map(p => mulComplexScalar(p, this.scaleFactor));
        const commands = [`M ${scaled[0].re.toFixed(4)} ${scaled[0].im.toFixed(4)}`];
        for (let i = 1; i < scaled.length; i += 1) {
          commands.push(`L ${scaled[i].re.toFixed(4)} ${scaled[i].im.toFixed(4)}`);
        }
        this.elements.push(`<path d="${commands.join(' ')}" fill="none" stroke="${color}" stroke-width="${width}" stroke-linecap="round" stroke-linejoin="round" />`);
      }

      makeLinePattern({ spacing = 10, angle = 0, color = '#000000', strokeWidth = 1, opacity = 0.6 } = {}) {
        const id = `pattern_${++this.patternCount}`;
        const safeSpacing = Math.max(0.5, spacing);
        const pattern = [`<pattern id="${id}" patternUnits="userSpaceOnUse" width="${safeSpacing}" height="${safeSpacing}" patternTransform="rotate(${angle})">`,
          `<line x1="0" y1="0" x2="0" y2="${safeSpacing}" stroke="${color}" stroke-width="${strokeWidth}" stroke-opacity="${opacity}" />`,
          `<line x1="${safeSpacing}" y1="0" x2="${safeSpacing}" y2="${safeSpacing}" stroke="${color}" stroke-width="${strokeWidth}" stroke-opacity="${opacity}" />`,
          '</pattern>'];
        this.defs.push(pattern.join(''));
        return id;
      }

      drawGroupOutline(points, { stroke = '#000000', strokeWidth = 1, fill = 'none', fillOpacity = 1, fillPattern = null } = {}) {
        if (!points.length) {
          return;
        }
        const scaled = points.map(p => mulComplexScalar(p, this.scaleFactor));
        let fillAttr = fill;
        if (fillPattern) {
          const patternId = this.makeLinePattern(fillPattern);
          fillAttr = `url(#${patternId})`;
        }
        const attr = [`points="${scaled.map(p => `${p.re.toFixed(4)},${p.im.toFixed(4)}`).join(' ')}"`,
          `stroke="${stroke}"`,
          `stroke-width="${strokeWidth}"`,
          `fill="${fillAttr}"`];
        if (fillAttr !== 'none') {
          attr.push(`fill-opacity="${fillOpacity}"`);
        }
        this.elements.push(`<polygon ${attr.join(' ')} />`);
      }

      toString() {
        const defs = this.defs.length ? `<defs>${this.defs.join('')}</defs>` : '';
        return `<svg xmlns="http://www.w3.org/2000/svg" width="${this.size}" height="${this.size}" viewBox="${this.viewBox.join(' ')}" role="img">${defs}${this.elements.join('')}</svg>`;
      }
    }

    const ArcSelector = {
      select_arcs_for_gaps(circle, spiralCenter, numGaps = 2, mode = 'closest') {
        const pts = circle.intersections.map(entry => entry.point);
        const n = pts.length;
        const center = circle.center;
        const arcs = Array.from({ length: n }, (_, i) => [i, (i + 1) % n]);
        if (n < 2) {
          return [];
        }
        const midpoints = arcs.map(([i, j]) => midpointComplex(pts[i], pts[j]));
        const lineVec = subComplex(spiralCenter, center);
        const lineLen = absComplex(lineVec);
        const distanceToLine = (point) => {
          if (lineLen < 1e-6) {
            return distanceComplex(point, spiralCenter);
          }
          const dx = lineVec.re;
          const dy = lineVec.im;
          const px = point.re - center.re;
          const py = point.im - center.im;
          return Math.abs(dx * py - dy * px) / lineLen;
        };

        if (mode === 'closest' || mode === 'farthest') {
          const data = arcs.map((arc, idx) => ({ arc, dist: distanceToLine(midpoints[idx]) }));
          data.sort((a, b) => mode === 'closest' ? a.dist - b.dist : b.dist - a.dist);
          return data.slice(Math.min(numGaps, data.length)).map(entry => entry.arc);
        }

        if (mode === 'alternating') {
          if (numGaps >= n) {
            return [];
          }
          const interval = Math.max(1, Math.floor(n / (numGaps + 1)));
          return arcs.filter((_, idx) => (idx % interval) !== 0);
        }

        if (mode === 'all') {
          return arcs;
        }

        if (mode === 'random') {
          const rng = seededRandom(circle.id * 37 + n * 17);
          const indices = Array.from({ length: n }, (_, i) => i);
          indices.sort((a, b) => rng() - 0.5);
          const skip = new Set(indices.slice(0, Math.min(numGaps, n)));
          return arcs.filter((_, idx) => !skip.has(idx));
        }

        if (mode === 'symmetric') {
          const angles = midpoints.map(pt => argComplex(subComplex(pt, center)));
          const targetAngle = lineLen < 1e-6 ? 0 : argComplex(subComplex(spiralCenter, center));
          const diffs = angles.map(a => Math.abs(normalizeAngle(a - targetAngle)));
          const sortedIndices = diffs.map((v, idx) => ({ v, idx })).sort((a, b) => a.v - b.v).map(entry => entry.idx);
          const numHalfGaps = Math.floor(numGaps / 2);
          const skip = new Set();
          for (let k = 0; k < numHalfGaps && k < sortedIndices.length; k += 1) {
            const idx = sortedIndices[k];
            skip.add(idx);
            const midpoint = midpoints[idx];
            const oppositeAngle = argComplex(subComplex(midpoint, center)) + Math.PI;
            let bestIndex = 0;
            let bestDiff = Infinity;
            for (let i = 0; i < n; i += 1) {
              const ptAngle = argComplex(subComplex(pts[i], center));
              const diff = Math.abs(normalizeAngle(ptAngle - oppositeAngle));
              if (diff < bestDiff) {
                bestDiff = diff;
                bestIndex = i;
              }
            }
            for (let i = 0; i < arcs.length; i += 1) {
              if (arcs[i][0] === bestIndex) {
                skip.add(i);
                break;
              }
            }
          }
          if (numGaps % 2 !== 0 && lineLen > 1e-6) {
            const intersectionDistances = circle.intersections.map(entry => distanceToLine(entry.point));
            let closestIdx = 0;
            for (let i = 1; i < intersectionDistances.length; i += 1) {
              if (intersectionDistances[i] < intersectionDistances[closestIdx]) {
                closestIdx = i;
              }
            }
            for (let i = 0; i < arcs.length; i += 1) {
              if (arcs[i][0] === closestIdx) {
                skip.add(i);
                break;
              }
            }
          }
          return arcs.filter((_, idx) => !skip.has(idx));
        }

        if (mode === 'angular') {
          const angles = midpoints.map(pt => argComplex(subComplex(pt, center)));
          const targetAngle = lineLen < 1e-6 ? 0 : argComplex(subComplex(spiralCenter, center));
          const diffs = angles.map(a => Math.abs(normalizeAngle(a - targetAngle)));
          const data = arcs.map((arc, idx) => ({ arc, diff: diffs[idx] }));
          data.sort((a, b) => a.diff - b.diff);
          return data.slice(Math.min(numGaps, data.length)).map(entry => entry.arc);
        }

        return arcs;
      },
    };

    const DoyleMath = {
      d_(z, t, p, q) {
        const w = Math.pow(z, p / q);
        const s = (p * t + TWO_PI) / q;
        const cx = z * Math.cos(t) - w * Math.cos(s);
        const cy = z * Math.sin(t) - w * Math.sin(s);
        return cx * cx + cy * cy;
      },
      s_(z, p, q) {
        const w = Math.pow(z, p / q);
        const value = z + w;
        return value * value;
      },
      r_(z, t, p, q) {
        return this.d_(z, t, p, q) / this.s_(z, p, q);
      },
      solve(p, q) {
        const f = (z, t) => {
          const r01 = DoyleMath.r_(z, t, 0, 1);
          const rPQ = DoyleMath.r_(z, t, p, q);
          const w = Math.pow(z, p / q);
          const rpq = DoyleMath.r_(w, (p * t + TWO_PI) / q, 0, 1);
          return [r01 - rPQ, r01 - rpq];
        };
        let z = 2;
        let t = 0;
        for (let iter = 0; iter < 80; iter += 1) {
          const [f1, f2] = f(z, t);
          const norm = Math.hypot(f1, f2);
          if (!Number.isFinite(norm)) {
            break;
          }
          if (norm < 1e-12) {
            break;
          }
          const h = 1e-6;
          const [f1z, f2z] = f(z + h, t);
          const [f1t, f2t] = f(z, t + h);
          const j11 = (f1z - f1) / h;
          const j21 = (f2z - f2) / h;
          const j12 = (f1t - f1) / h;
          const j22 = (f2t - f2) / h;
          const det = j11 * j22 - j12 * j21;
          if (Math.abs(det) < 1e-12) {
            break;
          }
          const invDet = 1 / det;
          const dz = -(j22 * f1 - j12 * f2) * invDet;
          const dt = -(-j21 * f1 + j11 * f2) * invDet;
          let step = 1;
          let updated = false;
          while (step > 1e-6) {
            const candidateZ = z + dz * step;
            const candidateT = t + dt * step;
            if (candidateZ <= 0) {
              step *= 0.5;
              continue;
            }
            const [g1, g2] = f(candidateZ, candidateT);
            if (Math.hypot(g1, g2) < norm) {
              z = candidateZ;
              t = candidateT;
              updated = true;
              break;
            }
            step *= 0.5;
          }
          if (!updated) {
            z += dz;
            t += dt;
          }
          if (!Number.isFinite(z) || !Number.isFinite(t)) {
            break;
          }
          if (Math.abs(dz) < 1e-10 && Math.abs(dt) < 1e-10) {
            break;
          }
        }
        z = Math.max(z, 1e-6);
        const r = Math.sqrt(DoyleMath.r_(z, t, 0, 1));
        const a = mulComplexScalar(expi(t), z);
        const w = Math.pow(z, p / q);
        const angleB = (p * t + TWO_PI) / q;
        const b = mulComplexScalar(expi(angleB), w);
        return { a, b, r, mod_a: z, arg_a: t };
      },
    };

    class DoyleSpiral {
      constructor(p, q, t, { arcMode = 'closest', numGaps = 2, maxD = 2000 } = {}) {
        this.p = p;
        this.q = q;
        this.t = t;
        this.arcMode = arcMode;
        this.numGaps = numGaps;
        this.max_d = maxD;
        this.root = DoyleMath.solve(p, q);
        this.circles = [];
        this.outerCircles = [];
        this.arcGroups = {};
        this.fillPatternAngle = 0;
        this._isGenerated = false;
      }

      generateCircles() {
        const { r, a, b, mod_a: modA, arg_a: argA } = this.root;
        const scale = Math.pow(modA, this.t);
        const alpha = argA * this.t;
        const w = expi(alpha);
        const absA = absComplex(a);
        const minD = 1 / scale;
        let start = cloneComplex(this.root.a);
        const circles = [];
        for (let family = 0; family < this.q; family += 1) {
          let qv = cloneComplex(start);
          let modQ = absComplex(qv);
          while (modQ < this.max_d) {
            const center = mulComplexScalar(mulComplex(qv, w), scale);
            circles.push(new CircleElement(center, r * scale * modQ));
            qv = mulComplex(qv, a);
            modQ *= absA;
          }
          qv = divComplex(start, a);
          modQ = absComplex(qv);
          while (modQ > minD) {
            const center = mulComplexScalar(mulComplex(qv, w), scale);
            circles.push(new CircleElement(center, r * scale * modQ));
            qv = divComplex(qv, a);
            modQ /= absA;
          }
          start = mulComplex(start, b);
        }
        this.circles = circles;
        this._isGenerated = true;
      }

      generateOuterCircles() {
        const { r, a, b, mod_a: modA, arg_a: argA } = this.root;
        const scale = Math.pow(modA, this.t);
        const alpha = argA * this.t;
        const w = expi(alpha);
        const absA = absComplex(a);
        let start = cloneComplex(this.root.a);
        const outer = [];
        for (let family = 0; family < this.q; family += 1) {
          let qv = cloneComplex(start);
          while (absComplex(qv) * scale < this.max_d) {
            qv = mulComplex(qv, a);
          }
          const magnitude = absComplex(qv);
          if (magnitude * scale < this.max_d * absA * 2) {
            const center = mulComplexScalar(mulComplex(qv, w), scale);
            outer.push(new CircleElement(center, r * scale * magnitude, false));
          }
          start = mulComplex(start, b);
        }
        this.outerCircles = outer;
      }

      computeAllIntersections() {
        const all = [...this.circles, ...this.outerCircles];
        const tol = 1e-3;
        for (const circle of all) {
          circle.resetIntersections();
        }
        for (let i = 0; i < all.length; i += 1) {
          for (let j = i + 1; j < all.length; j += 1) {
            const c1 = all[i];
            const c2 = all[j];
            const pts = c1.getIntersectionPoints(c2, tol);
            if (!pts.length) {
              continue;
            }
            for (const pt of pts) {
              c1.addIntersection(pt, c2);
              c2.addIntersection(pt, c1);
            }
          }
        }
        for (const circle of all) {
          circle.finalizeIntersections(complex(0, 0));
        }
      }

      createGroupForCircle(circle, name = null) {
        const key = name || `circle_${circle.id}`;
        if (!this.arcGroups[key]) {
          this.arcGroups[key] = new ArcGroup(key);
        }
        return this.arcGroups[key];
      }

      _computeRingIndices() {
        const radii = this.circles.map(c => Number(c.radius.toFixed(6)));
        const unique = Array.from(new Set(radii)).sort((a, b) => a - b);
        const mapping = new Map();
        unique.forEach((value, idx) => {
          mapping.set(value, idx);
        });
        return mapping;
      }

      _createArcGroups(radiusToRing, spiralCenter, options, context) {
        for (const circle of this.circles) {
          if (circle.intersections.length !== 6) {
            continue;
          }
          const arcs = ArcSelector.select_arcs_for_gaps(circle, spiralCenter, this.numGaps, this.arcMode);
          if (!arcs.length) {
            continue;
          }
          const group = this.createGroupForCircle(circle);
          group.ring_index = radiusToRing.get(Number(circle.radius.toFixed(6))) ?? null;
          if (options.debugGroups) {
            const color = context.randomColorForId(circle.id);
            group.debug_fill = color;
            group.debug_stroke = '#000000';
          }
          for (const [i, j] of arcs) {
            const start = circle.intersections[i].point;
            const end = circle.intersections[j].point;
            const arc = new ArcElement(circle, start, end, 72, true);
            if (!options.addFillPattern && options.drawGroupOutline) {
              context.drawArc(arc);
            }
            group.addArc(arc);
          }
        }
      }

      _drawOuterClosureArcs(spiralCenter, options, context) {
        for (const circle of this.outerCircles) {
          if (circle.intersections.length < 2) {
            continue;
          }
          const points = circle.intersections.map(entry => entry.point);
          const distances = [];
          for (let i = 0; i < points.length; i += 1) {
            const j = (i + 1) % points.length;
            const midpoint = midpointComplex(points[i], points[j]);
            const dist = distanceComplex(midpoint, spiralCenter);
            distances.push({ dist, i, j });
          }
          distances.sort((a, b) => a.dist - b.dist);
          for (let idx = 1; idx < Math.min(3, distances.length); idx += 1) {
            const { i, j } = distances[idx];
            const arc = new ArcElement(circle, points[i], points[j], 72, true);
            if (options.redOutline || (!options.addFillPattern && options.drawGroupOutline)) {
              context.drawArc(arc, { color: options.redOutline ? '#ff0000' : '#000000', width: 1.2 });
            }
            const key = `outer_${circle.id}`;
            const group = this.createGroupForCircle(circle, key);
            group.ring_index = -1;
            if (options.debugGroups) {
              group.debug_fill = context.randomColorForId(circle.id + 1000);
              group.debug_stroke = '#000000';
            }
            group.addArc(arc);
          }
        }
      }

      _renderArramBoyle(context, options) {
        this.generateOuterCircles();
        this.computeAllIntersections();
        context.setNormalizationScale([...this.circles, ...this.outerCircles]);
        this.fillPatternAngle = options.fillPatternAngle;
        this.arcGroups = {};
        const spiralCenter = complex(0, 0);
        const radiusToRing = this._computeRingIndices();
        this._createArcGroups(radiusToRing, spiralCenter, options, context);
        this._drawOuterClosureArcs(spiralCenter, options, context);

        const innerGroups = Object.entries(this.arcGroups).filter(([key]) => !key.startsWith('outer_'));
        if (options.debugGroups) {
          for (const [, group] of innerGroups) {
            group.toSvgFill(context, { debug: true, fillOpacity: 0.25 });
          }
        }
        if (options.addFillPattern) {
          for (const [, group] of innerGroups) {
            const ringIdx = group.ring_index ?? 0;
            const angle = ringIdx * this.fillPatternAngle;
            group.toSvgFill(context, {
              patternFill: true,
              lineSettings: [options.fillPatternSpacing, angle],
              drawOutline: options.drawGroupOutline,
              fillOpacity: 0.5,
            });
          }
        } else if (options.drawGroupOutline) {
          for (const [, group] of innerGroups) {
            group.toSvgFill(context, { patternFill: false, drawOutline: true });
          }
        }
        if (options.redOutline) {
          let maxRing = -Infinity;
          for (const [, group] of innerGroups) {
            if (group.ring_index != null) {
              maxRing = Math.max(maxRing, group.ring_index);
            }
          }
          for (const [, group] of innerGroups) {
            if (group.ring_index === maxRing) {
              const arcs = group.arcs.slice(-2);
              for (const arc of arcs) {
                context.drawArc(arc, { color: '#ff0000', width: 1.2 });
              }
            }
          }
        }
      }

      _renderDoyle(context) {
        context.setNormalizationScale(this.circles);
        for (const circle of this.circles) {
          context.drawCircle(circle);
        }
      }

      toSvg({ mode = 'doyle', size = 800, debugGroups = false, addFillPattern = false, fillPatternSpacing = 5, fillPatternAngle = 0, redOutline = false, drawGroupOutline = true } = {}) {
        if (!this._isGenerated) {
          this.generateCircles();
        }
        const context = new DrawingContext(size);
        if (mode === 'doyle') {
          this._renderDoyle(context);
        } else {
          this._renderArramBoyle(context, {
            debugGroups,
            addFillPattern,
            fillPatternSpacing,
            fillPatternAngle,
            redOutline,
            drawGroupOutline,
          });
        }
        return context.toString();
      }

      toJsonDict() {
        const groups = [];
        for (const [key, group] of Object.entries(this.arcGroups)) {
          if (key.startsWith('outer_')) {
            continue;
          }
          let outline = group.getClosedOutline();
          if (!outline.length) {
            continue;
          }
          outline = outline.map(pt => [pt.re, pt.im]);
          const ringIndex = group.ring_index ?? 0;
          groups.push({
            id: group.id,
            name: group.name,
            ring_index: group.ring_index,
            line_angle: ringIndex * this.fillPatternAngle,
            outline,
            arc_count: group.arcs.length,
          });
        }
        return {
          spiral_params: {
            p: this.p,
            q: this.q,
            t: this.t,
            arc_mode: this.arcMode,
            num_gaps: this.numGaps,
          },
          arcgroups: groups,
        };
      }
    }

    function collectParams(form) {
      const data = new FormData(form);
      const params = {
        p: Number(data.get('p')) || 16,
        q: Number(data.get('q')) || 16,
        t: Number(data.get('t')) || 0,
        mode: data.get('mode') || 'arram_boyle',
        arc_mode: data.get('arc_mode') || 'closest',
        num_gaps: Number(data.get('num_gaps')) || 2,
        size: Number(data.get('size')) || 800,
        add_fill_pattern: form.querySelector('#togglePattern').checked,
        draw_group_outline: form.querySelector('#toggleOutline').checked,
        red_outline: form.querySelector('#toggleRed').checked,
        fill_pattern_spacing: Number(data.get('fill_pattern_spacing')) || 5,
        fill_pattern_angle: Number(data.get('fill_pattern_angle')) || 0,
        fill_pattern_offset: Number(data.get('fill_pattern_offset')) || 0,
      };
      return params;
    }

    document.addEventListener('DOMContentLoaded', () => {
      const form = document.getElementById('controlsForm');
      const statusEl = document.getElementById('statusMessage');
      const svgPreview = document.getElementById('svgPreview');
      const statsBlock = document.getElementById('stats');
      const statArcGroups = document.getElementById('statArcGroups');
      const statPolygons = document.getElementById('statPolygons');
      const statMode = document.getElementById('statMode');
      const tRange = document.getElementById('inputT');
      const tValue = document.getElementById('tValue');
      const fillToggle = document.getElementById('togglePattern');
      const fillSettings = document.getElementById('fillSettings');
      const viewButtons = Array.from(document.querySelectorAll('[data-view]'));
      const view2d = document.getElementById('view2d');
      const view3d = document.getElementById('view3d');
      const threeStage = document.getElementById('threeStage');
      const threeSettingsToggle = document.getElementById('threeSettingsToggle');
      const threeSettings = document.getElementById('threeSettings');
      const threeStats = document.getElementById('threeStats');
      const threeStatus = document.getElementById('threeStatus');

      let threeApp = null;
      let lastGeometry = null;
      let lastParams = null;

      function setStatus(message, state = 'idle') {
        statusEl.textContent = message;
        statusEl.classList.remove('loading', 'error');
        if (state !== 'idle') {
          statusEl.classList.add(state);
        }
      }

      function toggleFillSettings() {
        fillSettings.hidden = !fillToggle.checked;
      }

      function updateTValue() {
        tValue.textContent = Number(tRange.value).toFixed(2);
      }

      function ensureThreeApp() {
        if (threeApp) {
          return threeApp;
        }
        if (typeof THREE === 'undefined') {
          threeStatus.textContent = 'three.js failed to load';
          threeStatus.classList.add('error');
          return null;
        }
        threeApp = createThreeApp();
        return threeApp;
      }

      async function renderSpiral(showLoading = true) {
        const params = collectParams(form);
        if (showLoading) {
          setStatus('Rendering spiral…', 'loading');
        }
        try {
          const spiral = new DoyleSpiral(params.p, params.q, params.t, {
            arcMode: params.arc_mode,
            numGaps: params.num_gaps,
          });
          const svg = spiral.toSvg({
            mode: params.mode,
            size: params.size,
            addFillPattern: params.add_fill_pattern,
            fillPatternSpacing: params.fill_pattern_spacing,
            fillPatternAngle: params.fill_pattern_angle,
            redOutline: params.red_outline,
            debugGroups: false,
            drawGroupOutline: params.draw_group_outline,
          });
          svgPreview.innerHTML = svg;
          svgPreview.classList.remove('empty-state');

          let geometry = null;
          if (params.mode === 'arram_boyle') {
            geometry = spiral.toJsonDict();
            statArcGroups.textContent = geometry.arcgroups.length;
            statPolygons.textContent = geometry.arcgroups.reduce((sum, g) => sum + (g.arc_count || 0), 0);
            statsBlock.hidden = false;
          } else {
            statsBlock.hidden = true;
          }
          statMode.textContent = params.mode === 'arram_boyle' ? 'Arram-Boyle' : 'Classic Doyle';
          setStatus('Spiral updated. Ready for exploration.');
          lastGeometry = geometry;
          lastParams = params;
          const app = ensureThreeApp();
          if (app && geometry) {
            app.updateFromPayload(params, geometry);
          }
        } catch (error) {
          console.error(error);
          svgPreview.innerHTML = '<div class="empty-state">Unable to render spiral.</div>';
          svgPreview.classList.add('empty-state');
          setStatus(error.message || 'Unexpected error', 'error');
        }
      }

      const debouncedRender = (() => {
        let timer = null;
        return () => {
          clearTimeout(timer);
          timer = setTimeout(() => renderSpiral(false), 200);
        };
      })();

      form.addEventListener('input', event => {
        if (event.target === tRange) {
          updateTValue();
        }
        if (event.target === fillToggle) {
          toggleFillSettings();
        }
        debouncedRender();
      });

      form.addEventListener('submit', event => {
        event.preventDefault();
        renderSpiral(true);
      });

      viewButtons.forEach(button => {
        button.addEventListener('click', () => {
          if (button.classList.contains('active')) {
            return;
          }
          viewButtons.forEach(btn => {
            btn.classList.toggle('active', btn === button);
            btn.setAttribute('aria-pressed', btn === button ? 'true' : 'false');
          });
          const target = button.dataset.view;
          if (target === '3d') {
            view2d.hidden = true;
            view3d.hidden = false;
            const app = ensureThreeApp();
            if (app && lastGeometry) {
              app.updateFromPayload(lastParams || collectParams(form), lastGeometry);
            }
          } else {
            view2d.hidden = false;
            view3d.hidden = true;
          }
        });
      });

      threeSettingsToggle.addEventListener('click', () => {
        const expanded = threeSettingsToggle.getAttribute('aria-expanded') === 'true';
        threeSettingsToggle.setAttribute('aria-expanded', expanded ? 'false' : 'true');
        threeStage.classList.toggle('collapsed', expanded);
      });

      toggleFillSettings();
      updateTValue();
      renderSpiral(true);

      function createThreeApp() {
        const canvas = document.getElementById('threeCanvas');
        const statusMessage = document.getElementById('threeStatus');
        const statsBlock3d = document.getElementById('threeStats');
        const statArcGroups3d = document.getElementById('threeStatArcGroups');
        const statPolygons3d = document.getElementById('threeStatPolygons');
        const statParameters3d = document.getElementById('threeStatParameters');
        const rotationSpeed = document.getElementById('threeRotationSpeed');
        const rotationSpeedValue = document.getElementById('threeRotationSpeedValue');
        const manualRotation = document.getElementById('threeManualRotation');
        const manualRotationValue = document.getElementById('threeManualRotationValue');
        const pulseSlider = document.getElementById('threePulseSpeed');
        const pulseSpeedValue = document.getElementById('threePulseSpeedValue');
        const metalnessSlider = document.getElementById('threeMetalness');
        const metalnessValue = document.getElementById('threeMetalnessValue');
        const roughnessSlider = document.getElementById('threeRoughness');
        const roughnessValue = document.getElementById('threeRoughnessValue');
        const reloadGeometryBtn = document.getElementById('threeReloadGeometry');
        const loadJsonBtn = document.getElementById('threeLoadJson');
        const resetCameraBtn = document.getElementById('threeResetCamera');
        const fileInput = document.getElementById('threeFileInput');

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0e1a);
        scene.fog = new THREE.Fog(0x0a0e1a, 5, 15);

        const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
        camera.position.set(0, 0, 4);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        const ambient = new THREE.AmbientLight(0x404060, 0.4);
        scene.add(ambient);
        const key = new THREE.DirectionalLight(0xffffff, 1.2);
        key.position.set(5, 8, 7);
        key.castShadow = true;
        scene.add(key);
        const fill = new THREE.DirectionalLight(0x7799ff, 0.5);
        fill.position.set(-5, 3, -5);
        scene.add(fill);
        const rim = new THREE.DirectionalLight(0xffaa77, 0.6);
        rim.position.set(0, -5, -5);
        scene.add(rim);

        const spiralContainer = new THREE.Group();
        scene.add(spiralContainer);

        let cameraRotation = { x: 0, y: 0 };
        let cameraDistance = 4;
        let autoRotationSpeed = parseFloat(rotationSpeed.value);
        let pulseSpeed = parseFloat(pulseSlider.value);
        let metalness = parseFloat(metalnessSlider.value);
        let roughness = parseFloat(roughnessSlider.value);
        let animationStart = performance.now();
        let lastLoadedGeometry = null;

        const palette = [
          0xc0c0d0, 0xb0b0c0, 0xa8a8b8, 0x9898a8,
          0xd0d0e0, 0xb8b8c8, 0xa0a0b0, 0xc8c8d8,
          0x888898, 0xd8d8e8,
        ];

        function resizeRendererToDisplaySize() {
          const width = canvas.clientWidth;
          const height = canvas.clientHeight;
          if (canvas.width !== width || canvas.height !== height) {
            renderer.setSize(width, height, false);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
          }
        }

        function getColorForRing(i) {
          return palette[Math.abs(i) % palette.length];
        }

        function clearSpiral() {
          spiralContainer.children.forEach(mesh => {
            mesh.geometry.dispose();
            mesh.material.dispose();
          });
          spiralContainer.clear();
          spiralContainer.position.set(0, 0, 0);
          spiralContainer.rotation.set(0, 0, 0);
          spiralContainer.scale.set(1, 1, 1);
        }

        function createPolygonMesh(outline, ringIndex, lineAngle) {
          if (!outline || !outline.length) {
            return null;
          }
          const shape = new THREE.Shape();
          shape.moveTo(outline[0][0], outline[0][1]);
          for (let i = 1; i < outline.length; i += 1) {
            shape.lineTo(outline[i][0], outline[i][1]);
          }
          const geometry = new THREE.ExtrudeGeometry(shape, {
            depth: 0.05,
            bevelEnabled: true,
            bevelThickness: 0.01,
            bevelSize: 0.01,
            bevelSegments: 2,
          });
          const material = new THREE.MeshStandardMaterial({
            color: getColorForRing(ringIndex || 0),
            metalness,
            roughness,
            emissive: 0x000000,
          });
          const mesh = new THREE.Mesh(geometry, material);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          mesh.userData = {
            ringIndex,
            lineAngle: lineAngle || 0,
            isPulsing: false,
            wasInRange: false,
            pulseStart: 0,
          };
          return mesh;
        }

        function loadSpiralFromJSON(data) {
          if (!data || !Array.isArray(data.arcgroups)) {
            statusMessage.textContent = 'Invalid geometry payload.';
            statusMessage.classList.add('error');
            return;
          }
          clearSpiral();
          data.arcgroups.forEach(group => {
            const mesh = createPolygonMesh(group.outline, group.ring_index, group.line_angle);
            if (mesh) {
              spiralContainer.add(mesh);
            }
          });
          if (spiralContainer.children.length) {
            const box = new THREE.Box3().setFromObject(spiralContainer);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDimension = Math.max(size.x, size.y, size.z, 1e-6);
            const scale = 2.5 / maxDimension;
            spiralContainer.position.set(-center.x * scale, -center.y * scale, -center.z * scale);
            spiralContainer.scale.setScalar(scale);
            resetView();
          }
          statArcGroups3d.textContent = data.arcgroups.length;
          statPolygons3d.textContent = spiralContainer.children.length;
          statsBlock3d.hidden = false;
          statusMessage.textContent = '3D geometry ready.';
          statusMessage.classList.remove('error');
        }

        function updateMaterialsForRotation(rotationAngleDeg, timeSec) {
          const threshold = 20;
          const pulseDuration = 1 / Math.max(pulseSpeed, 0.0001);
          spiralContainer.children.forEach(mesh => {
            const lineAngle = mesh.userData.lineAngle || 0;
            const diff = Math.abs(((rotationAngleDeg - lineAngle + 450) % 180) - 90);
            const isInRange = diff < threshold;
            if (isInRange && !mesh.userData.wasInRange) {
              mesh.userData.isPulsing = true;
              mesh.userData.pulseStart = timeSec;
            }
            if (mesh.userData.isPulsing) {
              const elapsed = timeSec - mesh.userData.pulseStart;
              if (elapsed < pulseDuration) {
                const t = elapsed / pulseDuration;
                const s = Math.sin(t * Math.PI);
                mesh.material.emissive.setHex(0xffd700);
                mesh.material.emissiveIntensity = s * 0.8;
                mesh.material.metalness = metalness + 0.1 * s;
              } else {
                mesh.userData.isPulsing = false;
                mesh.material.emissive.setHex(0x000000);
                mesh.material.emissiveIntensity = 0;
                mesh.material.metalness = metalness;
              }
            }
            mesh.userData.wasInRange = isInRange;
          });
        }

        function updateCamera() {
          const { x, y } = cameraRotation;
          camera.position.x = cameraDistance * Math.sin(x) * Math.cos(y);
          camera.position.y = cameraDistance * Math.sin(y);
          camera.position.z = cameraDistance * Math.cos(x) * Math.cos(y);
          camera.lookAt(0, 0, 0);
        }

        function resetView() {
          cameraRotation = { x: 0, y: 0 };
          cameraDistance = 4;
          spiralContainer.rotation.set(0, 0, 0);
          manualRotation.value = '0';
          manualRotationValue.textContent = '0';
          animationStart = performance.now();
          updateCamera();
        }

        let isDragging = false;
        let previousPointer = null;

        canvas.addEventListener('pointerdown', event => {
          isDragging = true;
          previousPointer = { x: event.clientX, y: event.clientY };
          canvas.setPointerCapture(event.pointerId);
        });

        canvas.addEventListener('pointermove', event => {
          if (!isDragging || !previousPointer) {
            return;
          }
          const dx = event.clientX - previousPointer.x;
          const dy = event.clientY - previousPointer.y;
          cameraRotation.x += dx * 0.01;
          cameraRotation.y += dy * 0.01;
          cameraRotation.y = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, cameraRotation.y));
          previousPointer = { x: event.clientX, y: event.clientY };
          updateCamera();
        });

        canvas.addEventListener('pointerup', event => {
          isDragging = false;
          previousPointer = null;
          canvas.releasePointerCapture(event.pointerId);
        });

        canvas.addEventListener('pointerleave', () => {
          isDragging = false;
          previousPointer = null;
        });

        canvas.addEventListener('wheel', event => {
          event.preventDefault();
          cameraDistance += event.deltaY * 0.01;
          cameraDistance = Math.max(1, Math.min(15, cameraDistance));
          updateCamera();
        }, { passive: false });

        rotationSpeed.addEventListener('input', () => {
          autoRotationSpeed = parseFloat(rotationSpeed.value);
          rotationSpeedValue.textContent = autoRotationSpeed.toFixed(2);
        });

        pulseSlider.addEventListener('input', () => {
          pulseSpeed = parseFloat(pulseSlider.value);
          pulseSpeedValue.textContent = pulseSpeed.toFixed(1);
        });

        metalnessSlider.addEventListener('input', () => {
          metalness = parseFloat(metalnessSlider.value);
          metalnessValue.textContent = metalness.toFixed(2);
          spiralContainer.children.forEach(mesh => {
            mesh.material.metalness = metalness;
          });
        });

        roughnessSlider.addEventListener('input', () => {
          roughness = parseFloat(roughnessSlider.value);
          roughnessValue.textContent = roughness.toFixed(2);
          spiralContainer.children.forEach(mesh => {
            mesh.material.roughness = roughness;
          });
        });

        manualRotation.addEventListener('input', () => {
          manualRotationValue.textContent = manualRotation.value;
        });

        resetCameraBtn.addEventListener('click', resetView);

        reloadGeometryBtn.addEventListener('click', () => {
          if (lastLoadedGeometry) {
            loadSpiralFromJSON(lastLoadedGeometry);
            statusMessage.textContent = 'Geometry reloaded from current render.';
            statusMessage.classList.remove('error');
          } else {
            statusMessage.textContent = 'No geometry available yet. Render the spiral first.';
            statusMessage.classList.add('error');
          }
        });

        loadJsonBtn.addEventListener('click', () => fileInput.click());

        fileInput.addEventListener('change', event => {
          const [file] = event.target.files || [];
          if (!file) {
            return;
          }
          const reader = new FileReader();
          reader.onload = e => {
            try {
              const data = JSON.parse(e.target.result);
              loadSpiralFromJSON(data);
              statParameters3d.textContent = file.name;
              lastLoadedGeometry = data;
            } catch (err) {
              console.error(err);
              statusMessage.textContent = 'Unable to parse JSON file.';
              statusMessage.classList.add('error');
            }
          };
          reader.readAsText(file);
        });

        function animate(time) {
          requestAnimationFrame(animate);
          resizeRendererToDisplaySize();
          const timeSec = (time - animationStart) / 1000;
          const manualValue = parseFloat(manualRotation.value);
          let rotationDeg;
          if (autoRotationSpeed > 0 && Math.abs(manualValue) < 1e-6) {
            rotationDeg = (timeSec * autoRotationSpeed * 360) % 360;
          } else {
            rotationDeg = manualValue % 360;
          }
          spiralContainer.rotation.z = THREE.MathUtils.degToRad(rotationDeg);
          updateMaterialsForRotation(rotationDeg, timeSec);
          updateCamera();
          renderer.render(scene, camera);
        }

        requestAnimationFrame(animate);

        return {
          updateFromPayload(params, geometry) {
            if (!geometry || !Array.isArray(geometry.arcgroups)) {
              statusMessage.textContent = 'Switch to Arram-Boyle mode for 3D geometry.';
              statusMessage.classList.add('error');
              return;
            }
            loadSpiralFromJSON(geometry);
            statParameters3d.textContent = `p=${params.p}, q=${params.q}, t=${params.t.toFixed(2)}`;
            lastLoadedGeometry = geometry;
          },
        };
      }
    });
  })();
  </script>
</body>
</html>
