# -*- coding: utf-8 -*-
"""golden spiral

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ge2j9ls2mRCKHBBLcdP5YlZUPbWngI2F
"""

import numpy as np
from scipy.optimize import root
from scipy.spatial import cKDTree
import svgwrite
from IPython.display import display, SVG, clear_output
import ipywidgets as widgets
from typing import Any, Dict, List, Optional, Set, Tuple
import random
import math
import itertools
from matplotlib.path import Path as MplPath
import json

try:
    from shapely.geometry import Polygon as ShapelyPolygon
    from shapely.geometry import LineString, MultiLineString, GeometryCollection, MultiPolygon
    from shapely.prepared import prep as shapely_prep
    HAS_SHAPELY = True
except ImportError:  # pragma: no cover - shapely is optional
    ShapelyPolygon = None  # type: ignore
    LineString = None  # type: ignore
    MultiLineString = None  # type: ignore
    GeometryCollection = None  # type: ignore
    MultiPolygon = None  # type: ignore
    shapely_prep = None  # type: ignore
    HAS_SHAPELY = False

# ============================================
# Base Geometry and Drawing Classes
# ============================================

class Shape:
    """Base class for geometric shapes."""
    def __init__(self, visible: bool = True):
        """
        Initializes a Shape object.

        Args:
            visible: Whether the shape should be visible in the drawing.
        """
        self.visible = visible

    def to_svg(self, dwg: svgwrite.Drawing):
        """
        Abstract method to render the shape to an SVG element.

        Args:
            dwg: The svgwrite Drawing object.

        Raises:
            NotImplementedError: This method must be implemented by subclasses.
        """
        raise NotImplementedError

# ============================================
# GEOMETRY UTILITIES
# Helper functions for geometric calculations
# ============================================

def convert_polygon_to_array(polygon):
    """Convert polygon from complex numbers or list to numpy array."""
    if polygon and isinstance(polygon[0], complex):
        return np.array([(p.real, p.imag) for p in polygon])
    return np.array(polygon)

def apply_polygon_inset(polygon_array, offset):
    """Apply inward buffer to polygon using shapely."""
    if offset <= 0:
        return polygon_array

    if not HAS_SHAPELY or ShapelyPolygon is None:
        return polygon_array

    try:
        poly_shapely = ShapelyPolygon(polygon_array)
    except Exception:
        return polygon_array

    try:
        buffered = poly_shapely.buffer(-offset, join_style=2)
    except Exception:
        return polygon_array

    if buffered.is_empty:
        return None

    if hasattr(buffered, "geoms") and isinstance(buffered, MultiPolygon):
        buffered = max((geom for geom in buffered.geoms if not geom.is_empty),
                       key=lambda g: g.area,
                       default=None)
        if buffered is None:
            return None
    elif hasattr(buffered, "geoms") and GeometryCollection is not None and isinstance(buffered, GeometryCollection):
        polygons = [geom for geom in buffered.geoms if getattr(geom, "geom_type", "") == "Polygon" and not geom.is_empty]
        if not polygons:
            return None
        buffered = max(polygons, key=lambda g: g.area)

    try:
        exterior = buffered.exterior
    except AttributeError:
        return None

    return np.array(exterior.coords)

def line_segment_intersection(p1, p2, p3, p4):
    """Calculate intersection point between two line segments.
    
    Returns:
        Tuple (t, x, y) if intersection exists, None otherwise.
        t is the parameter along p1-p2 (0 to 1).
    """
    x1, y1 = p1
    x2, y2 = p2
    x3, y3 = p3
    x4, y4 = p4
    
    denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)
    if abs(denom) < 1e-10:
        return None
    
    t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom
    u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom
    
    if 0 <= t <= 1 and 0 <= u <= 1:
        ix = x1 + t * (x2 - x1)
        iy = y1 + t * (y2 - y1)
        return (t, ix, iy)
    return None

def find_line_polygon_intersections(line_start, line_end, polygon_edges):
    """Find all intersection points between a line and polygon edges.
    
    Returns:
        Sorted list of (t, x, y) tuples where t is parameter along line.
    """
    intersections = []
    for i in range(len(polygon_edges)):
        p3 = polygon_edges[i]
        p4 = polygon_edges[(i + 1) % len(polygon_edges)]
        
        intersection = line_segment_intersection(line_start, line_end, p3, p4)
        if intersection:
            intersections.append(intersection)
    
    return sorted(intersections, key=lambda x: x[0])


def _shapely_geometry_to_segments(geometry):
    """Convert shapely geometry result into a list of line segments."""
    segments = []
    if geometry is None or getattr(geometry, "is_empty", True):
        return segments

    geom_type = getattr(geometry, "geom_type", None)
    if geom_type == "LineString":
        coords = list(geometry.coords)
        if len(coords) >= 2:
            start = tuple(map(float, coords[0]))
            end = tuple(map(float, coords[-1]))
            segments.append((start, end))
    elif geom_type == "MultiLineString":
        for line in geometry.geoms:  # type: ignore[attr-defined]
            segments.extend(_shapely_geometry_to_segments(line))
    elif geom_type == "GeometryCollection":
        for geom in geometry.geoms:  # type: ignore[attr-defined]
            segments.extend(_shapely_geometry_to_segments(geom))

    return segments


class LineFillCache:
    """Cache for polygon line fills keyed by geometry and line settings."""

    def __init__(self):
        self._entries: Dict[
            Tuple[Any, float, float, float],
            Dict[str, Any]
        ] = {}
        self._polygon_cache: Dict[Tuple[Any, float], Optional[Dict[str, Any]]] = {}

    @staticmethod
    def _normalize(value: float) -> float:
        return round(float(value), 9)

    @staticmethod
    def polygon_signature_from_array(array: np.ndarray) -> Tuple[Tuple[float, float], ...]:
        return tuple((round(float(x), 9), round(float(y), 9)) for x, y in array)

    def _make_key(self, polygon_signature: Any, offset: float, spacing: float, angle: float) -> Tuple[Any, float, float, float]:
        return (
            polygon_signature,
            self._normalize(offset),
            self._normalize(spacing),
            self._normalize(angle),
        )

    def ensure_entry(
        self,
        polygon_signature: Any,
        offset: float,
        spacing: float,
        angle: float,
    ) -> Dict[str, Any]:
        key = self._make_key(polygon_signature, offset, spacing, angle)
        entry = self._entries.get(key)
        if entry is None:
            polygon_data = None
            if polygon_signature is not None:
                polygon_data = self._polygon_cache.get(
                    (polygon_signature, self._normalize(offset))
                )
            entry = {
                "polygon_data": polygon_data,
                "line_starts": None,
                "line_ends": None,
                "segments": None,
            }
            self._entries[key] = entry
        return entry

    def store_polygon_data(
        self,
        polygon_signature: Any,
        offset: float,
        polygon_data: Optional[Dict[str, Any]],
    ) -> None:
        normalized_offset = self._normalize(offset)
        if polygon_signature is not None:
            self._polygon_cache[(polygon_signature, normalized_offset)] = polygon_data

        for (sig, off, _, _), entry in self._entries.items():
            if sig == polygon_signature and off == normalized_offset:
                entry["polygon_data"] = polygon_data

    def store_line_endpoints(
        self,
        polygon_signature: Any,
        offset: float,
        spacing: float,
        angle: float,
        line_starts: Optional[np.ndarray],
        line_ends: Optional[np.ndarray],
    ) -> None:
        entry = self.ensure_entry(polygon_signature, offset, spacing, angle)
        entry["line_starts"] = line_starts
        entry["line_ends"] = line_ends

    def store_segments(
        self,
        polygon_signature: Any,
        offset: float,
        spacing: float,
        angle: float,
        segments: List[Tuple[Tuple[float, float], Tuple[float, float]]],
    ) -> None:
        entry = self.ensure_entry(polygon_signature, offset, spacing, angle)
        entry["segments"] = segments

    def prepare_polygon_data(
        self,
        base_array: np.ndarray,
        offset: float,
    ) -> Optional[Dict[str, Any]]:
        if base_array is None or len(base_array) < 3:
            return None

        clipped_array: Optional[np.ndarray]
        if offset:
            clipped_array = apply_polygon_inset(base_array, offset)
        else:
            clipped_array = np.array(base_array, dtype=float, copy=False)

        if clipped_array is None or len(clipped_array) < 3:
            return None

        polygon_path = MplPath(clipped_array)
        shapely_polygon = None
        prepared_polygon = None

        if HAS_SHAPELY and ShapelyPolygon is not None:
            try:
                shapely_polygon = ShapelyPolygon(clipped_array)
                if shapely_polygon.is_empty:
                    shapely_polygon = None
                elif not shapely_polygon.is_valid:
                    shapely_polygon = shapely_polygon.buffer(0)
                    if shapely_polygon.is_empty:
                        shapely_polygon = None
            except Exception:
                shapely_polygon = None

            if shapely_polygon is not None and shapely_prep is not None:
                try:
                    prepared_polygon = shapely_prep(shapely_polygon)
                except Exception:
                    prepared_polygon = None

        min_x, min_y = clipped_array[:, 0].min(), clipped_array[:, 1].min()
        max_x, max_y = clipped_array[:, 0].max(), clipped_array[:, 1].max()
        bbox_diag = math.hypot(max_x - min_x, max_y - min_y)
        centroid = clipped_array.mean(axis=0)

        return {
            "polygon_array": clipped_array,
            "polygon_path": polygon_path,
            "shapely_polygon": shapely_polygon,
            "prepared_polygon": prepared_polygon,
            "bbox_diag": bbox_diag,
            "centroid": centroid,
        }

    def compute_line_endpoints(
        self,
        polygon_data: Dict[str, Any],
        spacing: float,
        angle: float,
    ) -> Tuple[Optional[np.ndarray], Optional[np.ndarray]]:
        bbox_diag = polygon_data.get("bbox_diag")
        centroid = polygon_data.get("centroid")

        if not bbox_diag or centroid is None:
            return None, None

        theta = math.radians(angle)
        line_dir = np.array([math.cos(theta), math.sin(theta)])
        perp_dir = np.array([-line_dir[1], line_dir[0]])

        num_lines = int(bbox_diag / max(1e-6, spacing)) + 3
        offsets = np.arange(-num_lines, num_lines + 1, dtype=float)[:, None] * spacing
        offset_vectors = offsets * perp_dir
        span = line_dir * bbox_diag * 2
        start_base = centroid - span
        end_base = centroid + span
        line_starts = start_base + offset_vectors
        line_ends = end_base + offset_vectors

        return line_starts, line_ends


def lines_in_polygon(
    polygon,
    line_spacing=5,
    angle=0,
    color="#000000",
    stroke_width=0.5,
    offset=0,
    *,
    polygon_array: Optional[np.ndarray] = None,
    polygon_path: Optional[MplPath] = None,
    shapely_polygon=None,
    prepared_polygon=None,
    bbox_diag: Optional[float] = None,
    centroid: Optional[np.ndarray] = None,
    line_starts: Optional[np.ndarray] = None,
    line_ends: Optional[np.ndarray] = None,
):
    """Generate parallel lines clipped to polygon bounds.

    Args:
        polygon: List of complex numbers or Nx2 array of polygon vertices
        line_spacing: Distance between parallel lines
        angle: Line angle in degrees (0 = horizontal)
        color: Line color (unused, kept for compatibility)
        stroke_width: Line width (unused, kept for compatibility)
        offset: Inward offset from polygon edge in pixels

    Keyword Args:
        polygon_array: Precomputed Nx2 array of polygon vertices (after inset)
        polygon_path: Precomputed matplotlib path for point-in-polygon checks
        shapely_polygon: Cached shapely polygon for clipping
        prepared_polygon: Prepared shapely polygon for quick intersection tests
        bbox_diag: Precomputed bounding box diagonal length
        centroid: Precomputed polygon centroid
        line_starts: Prebuilt start points for candidate lines
        line_ends: Prebuilt end points for candidate lines

    Returns:
        List of line segment tuples ((x1, y1), (x2, y2))
    """
    if polygon_array is None:
        polygon_array = convert_polygon_to_array(polygon)
    if polygon_array is None or polygon_array.shape[0] < 3:
        return []

    # Apply inward offset if specified (used when no cached array provided)
    if offset:
        polygon_array = apply_polygon_inset(polygon_array, offset)
        if polygon_array is None or len(polygon_array) < 3:
            return []
        polygon_path = None
        shapely_polygon = None
        prepared_polygon = None
        line_starts = None
        line_ends = None

    if polygon_path is None:
        polygon_path = MplPath(polygon_array)

    if line_starts is None or line_ends is None:
        if centroid is None:
            centroid = polygon_array.mean(axis=0)

        if bbox_diag is None:
            min_x, min_y = polygon_array[:, 0].min(), polygon_array[:, 1].min()
            max_x, max_y = polygon_array[:, 0].max(), polygon_array[:, 1].max()
            bbox_diag = math.hypot(max_x - min_x, max_y - min_y)
        if not bbox_diag:
            return []

        # Calculate line direction and perpendicular offset direction
        theta = math.radians(angle)
        line_dir = np.array([math.cos(theta), math.sin(theta)])
        perp_dir = np.array([-line_dir[1], line_dir[0]])

        # Generate parallel lines
        num_lines = int(bbox_diag / max(1e-6, line_spacing)) + 3
        offsets = np.arange(-num_lines, num_lines + 1, dtype=float)[:, None] * line_spacing
        offset_vectors = offsets * perp_dir
        span = line_dir * bbox_diag * 2
        start_base = centroid - span
        end_base = centroid + span
        line_starts = start_base + offset_vectors
        line_ends = end_base + offset_vectors
    else:
        line_starts = np.asarray(line_starts, dtype=float)
        line_ends = np.asarray(line_ends, dtype=float)
        if line_starts.shape[0] == 0 or line_ends.shape[0] == 0:
            return []

    line_segments = []

    # Use shapely when available for robust clipping
    if HAS_SHAPELY and shapely_polygon is not None and LineString is not None and MultiLineString is not None:
        lines_to_clip = []
        for start, end in zip(line_starts, line_ends):
            line = LineString([tuple(start), tuple(end)])
            if prepared_polygon is None or prepared_polygon.intersects(line):
                lines_to_clip.append(line)

        if lines_to_clip:
            if len(lines_to_clip) == 1:
                clipped = shapely_polygon.intersection(lines_to_clip[0])
            else:
                multi = MultiLineString(lines_to_clip)
                clipped = shapely_polygon.intersection(multi)

            line_segments.extend(
                ((float(x1), float(y1)), (float(x2), float(y2)))
                for (x1, y1), (x2, y2) in _shapely_geometry_to_segments(clipped)
                if (x1, y1) != (x2, y2)
            )

        return line_segments

    # Fallback: manual clipping using polygon intersections
    for start, end in zip(line_starts, line_ends):
        intersections = find_line_polygon_intersections(start, end, polygon_array)

        for j in range(0, len(intersections) - 1, 2):
            _, x1, y1 = intersections[j]
            _, x2, y2 = intersections[j + 1]

            mid_x, mid_y = (x1 + x2) / 2, (y1 + y2) / 2
            if polygon_path.contains_point((mid_x, mid_y)):
                line_segments.append(((x1, y1), (x2, y2)))

    return line_segments

# ============================================
# DRAWING CONTEXT
# SVG rendering and coordinate normalization
# ============================================

class DrawingContext:
    """
    Handles SVG drawing and coordinate normalization.

    Manages the SVG drawing object and scales geometric elements to fit within the viewbox.
    """
    def __init__(self, size: int = 800):
        """
        Initializes a DrawingContext.

        Args:
            size: The size of the square drawing area in pixels.
        """
        self.size = size
        self.dwg = svgwrite.Drawing(size=(size, size))
        self.scale_factor = 1.0
        self._line_fill_cache = LineFillCache()

    def set_normalization_scale(self, elements: List['CircleElement']):
        """
        Calculates and sets the scale factor to fit elements into the viewbox.

        The scale factor is determined by the maximum extent of the circles (center + radius).

        Args:
            elements: A list of CircleElement objects to consider for scaling.
        """
        if not elements:
            self.scale_factor = 1.0
            self.dwg.viewbox(-self.size/2, -self.size/2, self.size, self.size)
            return

        coords = [c.center for c in elements]
        radii = [c.radius for c in elements]

        # Find the maximum extent including circle radii
        max_extent = max(max(abs(z.real) + r, abs(z.imag) + r) for z, r in zip(coords, radii))

        # Tighter padding: scale such that the max extent fits within 95% of the viewbox half-size
        self.scale_factor = (self.size / 2.1) / max_extent
        # Set the viewbox to center the drawing
        self.dwg.viewbox(-self.size/2, -self.size/2, self.size, self.size)


    def draw_scaled(self, element: Shape, **kwargs):
        """
        Draws a shape element after scaling its coordinates.

        Args:
            element: The Shape element to draw.
            **kwargs: Additional keyword arguments to pass to the element's to_svg method.
        """
        if isinstance(element, CircleElement):
            # Apply scaling to center and radius
            scaled_center = element.center * self.scale_factor
            scaled_radius = element.radius * self.scale_factor
            # Create a temporary scaled element for drawing purposes
            scaled_element = CircleElement(scaled_center, scaled_radius, element.visible)
            svg_element = scaled_element.to_svg(self.dwg, **kwargs)

        elif isinstance(element, ArcElement):
            if not element.visible:
                svg_element = None
            else:
                points = element.get_cached_points()
                if points is None:
                    points = element.get_points()

                if not points:
                    svg_element = None
                else:
                    scaled_points = [p * self.scale_factor for p in points]
                    color = kwargs.get("color", "#000000")
                    width = kwargs.get("width", 1.2)
                    path_data = ["M", f"{scaled_points[0].real},{scaled_points[0].imag}"]
                    path_data.extend(f"L{p.real},{p.imag}" for p in scaled_points[1:])
                    svg_element = self.dwg.path(
                        d=" ".join(path_data),
                        fill="none",
                        stroke=color,
                        stroke_width=width
                    )

        else:
            # Unknown element type; skip drawing
            svg_element = None

        if svg_element is not None:
            self.dwg.add(svg_element)

    def make_line_pattern(self, pattern_id="linePattern", spacing=10, angle=45, color="black", stroke_width=1):
        """Create a robust, angle-agnostic parallel line pattern.

        - spacing: distance between lines in user units (pixels)
        - angle: rotation in degrees (0 = vertical lines); positive is CCW
        """
        # Define a square pattern tile in user space; rotate the pattern itself
        pattern = self.dwg.pattern(
            id=pattern_id,
            patternUnits="userSpaceOnUse",
            size=(spacing, spacing),
        )

        # Rotate the pattern so the single vertical line becomes angled globally
        pattern['patternTransform'] = f"rotate({angle})"

        # Draw a vertical line spanning the tile height; duplicate at tile edge to avoid seams
        line_style = {
            'stroke': color,
            'stroke_width': stroke_width,
            'stroke_linecap': 'butt',
        }
        pattern.add(self.dwg.line(start=(0, 0), end=(0, spacing), **line_style))
        # Edge duplicate to mitigate antialiasing gaps at tile boundaries
        pattern.add(self.dwg.line(start=(spacing, 0), end=(spacing, spacing), **line_style))

        # Register pattern in defs
        self.dwg.defs.add(pattern)
        return pattern
    
    def _draw_clipped_line_fill(self, coords, points, stroke, stroke_width, line_pattern_settings, draw_outline, line_offset):
        """Draw polygon with clipped parallel line fill."""
        line_spacing, line_angle = line_pattern_settings

        base_array = convert_polygon_to_array(points)
        polygon_signature = None
        if base_array is not None and len(base_array) >= 3:
            polygon_signature = LineFillCache.polygon_signature_from_array(base_array)

        cache_entry = self._line_fill_cache.ensure_entry(
            polygon_signature,
            line_offset,
            line_spacing,
            line_angle,
        )

        polygon_data = cache_entry.get("polygon_data")
        if polygon_signature is not None and polygon_data is None:
            polygon_data = self._line_fill_cache.prepare_polygon_data(base_array, line_offset)
            self._line_fill_cache.store_polygon_data(polygon_signature, line_offset, polygon_data)
            polygon_data = cache_entry.get("polygon_data")

        if polygon_data is None:
            line_segments = cache_entry.get("segments")
            if line_segments is None:
                line_segments = []
                self._line_fill_cache.store_segments(
                    polygon_signature,
                    line_offset,
                    line_spacing,
                    line_angle,
                    line_segments,
                )
        else:
            line_starts = cache_entry.get("line_starts")
            line_ends = cache_entry.get("line_ends")
            if line_starts is None or line_ends is None:
                line_starts, line_ends = self._line_fill_cache.compute_line_endpoints(
                    polygon_data,
                    line_spacing,
                    line_angle,
                )
                self._line_fill_cache.store_line_endpoints(
                    polygon_signature,
                    line_offset,
                    line_spacing,
                    line_angle,
                    line_starts,
                    line_ends,
                )

            line_segments = cache_entry.get("segments")
            if line_segments is None:
                if line_starts is None or line_ends is None:
                    line_segments = []
                else:
                    line_segments = lines_in_polygon(
                        points,
                        line_spacing=line_spacing,
                        angle=line_angle,
                        offset=0,
                        polygon_array=polygon_data.get("polygon_array"),
                        polygon_path=polygon_data.get("polygon_path"),
                        shapely_polygon=polygon_data.get("shapely_polygon"),
                        prepared_polygon=polygon_data.get("prepared_polygon"),
                        bbox_diag=polygon_data.get("bbox_diag"),
                        centroid=polygon_data.get("centroid"),
                        line_starts=line_starts,
                        line_ends=line_ends,
                    )

                self._line_fill_cache.store_segments(
                    polygon_signature,
                    line_offset,
                    line_spacing,
                    line_angle,
                    line_segments,
                )

        # Optionally draw polygon outline
        if draw_outline:
            self.dwg.add(self.dwg.polygon(
                points=coords,
                fill="none", 
                stroke=stroke, 
                stroke_width=stroke_width
            ))
        
        # Draw clipped line segments
        line_color = stroke or "#000000"
        for (x1, y1), (x2, y2) in line_segments:
            self.dwg.add(self.dwg.line(
                start=(x1, y1), 
                end=(x2, y2),
                stroke=line_color, 
                stroke_width=0.5
            ))
    
    def draw_group_outline(self, points: List[complex], fill: Optional[str] = None, 
                          stroke: Optional[str] = None, stroke_width: float = 1.0, 
                          line_pattern_settings = (3, 0), use_clipped_lines: bool = False, 
                          draw_outline: bool = True, line_offset: float = 0):
        """Draw a polygon with optional line pattern fill.
        
        Args:
            points: Complex numbers representing polygon vertices
            fill: Fill type ("pattern", "clipped_lines", color, or None)
            stroke: Outline color
            stroke_width: Outline width
            line_pattern_settings: Tuple of (spacing, angle) for line fills
            use_clipped_lines: Use precise clipped lines instead of SVG patterns
            draw_outline: Whether to draw polygon outline
            line_offset: Inward offset for line clipping
        """
        if not points:
            return
        
        coords = [(p.real, p.imag) for p in points]
        
        # Use clipped lines for pattern fills (new method)
        if use_clipped_lines or fill in ("pattern", "clipped_lines"):
            self._draw_clipped_line_fill(
                coords, points, stroke, stroke_width, 
                line_pattern_settings, draw_outline, line_offset
            )
        elif fill is not None:
            # Solid color fill
            self.dwg.add(self.dwg.polygon(
                points=coords, 
                fill=fill, 
                stroke=stroke, 
                stroke_width=stroke_width
            ))
        else:
            # No fill - just outline
            self.dwg.add(self.dwg.polyline(
                points=coords, 
                fill="none", 
                stroke=stroke or "#000000", 
                stroke_width=stroke_width
            ))


    def to_string(self) -> str:
        """
        Returns the SVG drawing as a string.
        """
        return self.dwg.tostring()

class CircleElement(Shape):
    """
    Represents a circle in the geometry, handling intersections.

    Each circle has a unique ID, a center (complex number), and a radius.
    It can compute intersections with other circles and find its neighbours.
    """
    _id_counter = 0

    def __init__(self, center: complex, radius: float, visible: bool = True):
        """
        Initializes a CircleElement.

        Args:
            center: The center of the circle as a complex number.
            radius: The radius of the circle.
            visible: Whether the circle should be visible in the drawing.
        """
        super().__init__(visible)
        CircleElement._id_counter += 1
        self.id = CircleElement._id_counter
        self.center = complex(center)
        self.radius = float(radius)
        # List of (point: complex, other_circle: CircleElement)
        self.intersections: List[Tuple[complex, 'CircleElement']] = []
        self.neighbours: Set['CircleElement'] = set()

    def _get_intersection_points(self, other: 'CircleElement', tol: float = 1e-6) -> List[complex]:
        """
        Calculates the intersection points between this circle and another.

        Uses the Law of Cosines to find the distance from the center to the chord connecting
        the intersection points, then finds the points on the circle along the perpendicular vector.

        Args:
            other: The other CircleElement to intersect with.
            tol: Tolerance for floating point comparisons.

        Returns:
            A list of complex numbers representing the intersection points (0, 1, or 2 points).
        """
        d = abs(self.center - other.center)
        r1, r2 = self.radius, other.radius

        # Check for no intersection, tangency (external or internal), or one circle contained within another
        if d > r1 + r2 + tol or d < abs(r1 - r2) - tol or d < tol:
            return []

        # Distance 'a' from center 1 to the chord connecting intersection points
        a = (r1**2 - r2**2 + d**2) / (2 * d)
        # Half the length of the chord, squared
        h_sq = r1**2 - a**2
        if h_sq < -tol: # Should not happen with checks above, but floating point safety
            return []
        # Half the length of the chord
        h = np.sqrt(max(h_sq, 0))

        # Midpoint of the chord
        mid = self.center + a * (other.center - self.center) / d
        # Vector perpendicular to the line between centers, scaled by 1/d
        perp_unit = 1j * (other.center - self.center) / d

        # The two intersection points
        p1, p2 = mid + h * perp_unit, mid - h * perp_unit

        # If h is near zero, the points are the same (tangency)
        return [p1] if h < tol else [p1, p2]

    def compute_intersections(self, circles: List['CircleElement'], start_reference: Optional[complex] = None, tol: float = 1e-3):
        """
        Computes and sorts intersections sequentially clockwise around the circle.
        The first point is chosen as the one closest to start_reference.

        Args:
            circles: A list of other CircleElement objects to compute intersections with.
            start_reference: A complex number used as a reference point to determine the starting point for sorting.
                             If None, the circle's center is used.
            tol: Tolerance for floating point comparisons when identifying unique points.
        """
        self.intersections.clear()
        self.neighbours.clear()
        seen = set()

        for other in circles:
            if other is self:
                continue
            # Get intersection points with another circle
            pts = self._get_intersection_points(other, tol)
            for p in pts:
                # Use a slightly coarse rounding for deduplication of points
                key = (round(p.real, 6), round(p.imag, 6))
                if key not in seen:
                    self.intersections.append((p, other))
                    seen.add(key)
                    self.neighbours.add(other)

        if not self.intersections:
            return

        c = self.center
        # Default reference point is the circle's center
        if start_reference is None:
            start_reference = c

        # Choose the starting intersection by proximity to the reference point
        start_idx = int(np.argmin([abs(p - start_reference) for p, _ in self.intersections]))
        start_point = self.intersections[start_idx][0]
        start_angle = np.angle(start_point - c)

        def clockwise_offset(angle):
            """Compute clockwise offset from start_angle in [0, 2pi)."""
            # The angle is relative to the center of *this* circle
            offset = (start_angle - angle) % (2 * np.pi)
            return offset

        # Sort intersections by clockwise offset from the starting point
        self.intersections.sort(key=lambda x: clockwise_offset(np.angle(x[0] - c)))

    def get_neighbour_circles(
        self,
        k: Optional[int] = None,
        spiral_center: complex = 0+0j,
        clockwise: bool = True,
        tie_by_distance: bool = True
    ) -> List['CircleElement']:
        """
        Return neighbours sorted by their rotation around `spiral_center` relative to this circle.

        Args:
            k: Optionally limit to the k nearest neighbours (by center distance) BEFORE angular sorting.
            spiral_center: the center of the Doyle spiral (use 0+0j in your code).
            clockwise: if True, returns neighbours in clockwise order around the spiral center
                     starting from this circle's radial direction.
            tie_by_distance: if two neighbours have nearly identical relative angle, break ties using distance.

        Returns:
            A list of neighbour CircleElement objects, sorted according to the specified criteria.
        """
        neighbours = list(self.neighbours)
        if not neighbours:
            return []

        # Optionally keep only k nearest by center distance BEFORE angular ordering:
        if k is not None and len(neighbours) > k:
            neighbours.sort(key=lambda c: abs(c.center - self.center))
            neighbours = neighbours[:k]

        # Precompute base angle of this circle around spiral center
        base_angle = np.angle(self.center - spiral_center)

        def relative_angle_to_base(other: 'CircleElement') -> float:
            # angle of neighbour around spiral center
            a = np.angle(other.center - spiral_center)
            # relative in [0, 2*pi)
            rel = (a - base_angle) % (2 * np.pi)
            return rel

        # Build sort keys: primary = relative angle, secondary = distance (optional)
        if tie_by_distance:
            neighbours.sort(key=lambda c: (relative_angle_to_base(c), abs(c.center - self.center)))
        else:
            neighbours.sort(key=relative_angle_to_base)

        # numpy.angle gives CCW angles increasing; `rel` increases CCW from base direction.
        # If user wants clockwise order, reverse the CCW ordering.
        if clockwise:
            neighbours = list(reversed(neighbours))

        return neighbours


    def to_svg(self, dwg: svgwrite.Drawing, color="#4CB39B", opacity=0.8):
        """
        Renders the circle to an SVG element.

        Args:
            dwg: The svgwrite Drawing object.
            color: The fill color of the circle.
            opacity: The fill opacity of the circle.

        Returns:
            An svgwrite Circle object, or None if the circle is not visible.
        """
        if not self.visible:
            return None
        cx, cy = self.center.real, self.center.imag
        return dwg.circle(center=(cx, cy), r=self.radius, fill=color, fill_opacity=opacity)

class ArcElement(Shape):
    """
    Represents a circular arc segment between two intersection points.

    An arc is defined by the circle it lies on and its start and end points.
    """
    def __init__(self, circle: CircleElement, start: complex, end: complex, steps: int = 40, visible: bool = True):
        """
        Initializes an ArcElement.

        Args:
            circle: The CircleElement the arc lies on.
            start: The starting point of the arc as a complex number.
            end: The ending point of the arc as a complex number.
            steps: The number of discrete points to use for rendering the arc.
            visible: Whether the arc should be visible in the drawing.
        """
        super().__init__(visible)
        self.circle = circle
        self._points_cache: Optional[List[complex]] = None
        self._start: complex = 0j
        self._end: complex = 0j
        self._steps: int = 0
        self.start = start
        self.end = end
        self.steps = steps

    def _invalidate_points_cache(self):
        """Invalidate the cached arc sample points."""
        self._points_cache = None

    @property
    def start(self) -> complex:
        return self._start

    @start.setter
    def start(self, value: complex):
        new_value = complex(value)
        if getattr(self, "_start", None) != new_value:
            self._start = new_value
            self._invalidate_points_cache()

    @property
    def end(self) -> complex:
        return self._end

    @end.setter
    def end(self, value: complex):
        new_value = complex(value)
        if getattr(self, "_end", None) != new_value:
            self._end = new_value
            self._invalidate_points_cache()

    @property
    def steps(self) -> int:
        return self._steps

    @steps.setter
    def steps(self, value: int):
        new_value = int(value)
        if new_value < 1:
            new_value = 1
        if getattr(self, "_steps", None) != new_value:
            self._steps = new_value
            self._invalidate_points_cache()

    def get_cached_points(self) -> Optional[List[complex]]:
        """Return the cached arc sample points if available."""
        return self._points_cache

    def get_points(self) -> List[complex]:
        """
        Calculates the discrete points defining the arc.

        Calculates the angles of the start and end points relative to the circle's center,
        then generates a sequence of points along the arc.

        Returns:
            A list of complex numbers representing the points along the arc.
        """
        if self._points_cache is not None:
            return self._points_cache

        c = self.circle.center
        r = self.circle.radius
        a1 = np.angle(self.start - c)
        a2 = np.angle(self.end - c)

        # Calculate the clockwise angular difference [0, 2pi)
        delta = (a2 - a1 + 2 * np.pi) % (2 * np.pi)

        # Arc is drawn clockwise; use the smaller angular magnitude direction if needed
        if delta > np.pi:
            delta -= 2 * np.pi  # Result in [-2pi, 0] or [-pi, pi] if delta was > pi

        # Generate points along the arc using linspace for angles
        angles = np.linspace(a1, a1 + delta, self.steps)
        self._points_cache = [c + r * np.exp(1j * a) for a in angles]
        return self._points_cache

    def to_svg(self, dwg: svgwrite.Drawing, color="#000000", width=1.2):
        """
        Renders the arc to an SVG element.

        Args:
            dwg: The svgwrite Drawing object.
            color: The stroke color of the arc.
            width: The stroke width of the arc.

        Returns:
            An svgwrite Path object representing the arc, or None if the arc is not visible.
        """
        if not self.visible:
            return None
        # Get the discrete points for the arc
        pts = self.get_points()
        if not pts:
            return None
        # Create a path string from the points
        path_data = ["M", f"{pts[0].real},{pts[0].imag}"] + [f"L{p.real},{p.imag}" for p in pts[1:]]
        return dwg.path(d=" ".join(path_data), fill="none", stroke=color, stroke_width=width)

# ============================================
# Animation helpers for pattern assignments
# ============================================

GOLDEN_RATIO = (1 + math.sqrt(5)) / 2


def wrap_angle(angle: float) -> float:
    tau = 2 * math.pi
    result = angle % tau
    return result + tau if result < 0 else result


def mod1(value: float) -> float:
    result = value % 1.0
    return result + 1.0 if result < 0 else result


def balanced_groups_from_sorted(scored: List[Tuple[float, int]], frame_count: int) -> List[List[int]]:
    groups: List[List[int]] = [[] for _ in range(max(frame_count, 0))]
    if frame_count <= 0 or not scored:
        return groups
    total = len(scored)
    base_size = total // frame_count
    remainder = total % frame_count
    cursor = 0
    for frame in range(frame_count):
        size = base_size + (1 if frame < remainder else 0)
        for _ in range(size):
            if cursor >= total:
                break
            groups[frame].append(scored[cursor][1])
            cursor += 1
    if cursor < total:
        last_group = groups[-1]
        while cursor < total:
            last_group.append(scored[cursor][1])
            cursor += 1
    return groups


def derive_frame_count(item_count: int, angle_step: float) -> int:
    if item_count <= 0:
        return 0
    step = abs(angle_step)
    if not math.isfinite(step) or step <= 1e-6:
        return item_count
    approx = round(360 / step)
    if approx <= 0 or not math.isfinite(approx):
        return item_count
    return max(1, min(item_count, approx))


def sequential_frame_map(item_count: int, frame_count: int) -> Dict[int, int]:
    assignments: Dict[int, int] = {}
    if item_count <= 0 or frame_count <= 0:
        return assignments
    for idx in range(item_count):
        frame = min(frame_count - 1, int((idx * frame_count) / item_count))
        assignments[idx] = frame
    return assignments


def groups_to_frame_map(grouped: Optional[List[List[int]]], item_count: int, frame_count: int) -> Dict[int, int]:
    assignments: Dict[int, int] = {}
    if frame_count <= 0 or not grouped:
        return assignments
    for frame, members in enumerate(grouped):
        if not members:
            continue
        clamped = min(frame_count - 1, max(0, frame))
        for idx in members:
            if 0 <= idx < item_count and idx not in assignments:
                assignments[idx] = clamped
    if len(assignments) == item_count:
        return assignments
    missing = [idx for idx in range(item_count) if idx not in assignments]
    if not missing:
        return assignments
    for order, idx in enumerate(missing):
        frame = min(frame_count - 1, int((order * frame_count) / len(missing)))
        assignments[idx] = frame
    return assignments


def compute_log_spiral_groups(items: List[Dict[str, float]], frame_count: int, beta: float = 1.0) -> List[List[int]]:
    scored: List[Tuple[float, int]] = []
    for idx, item in enumerate(items):
        rho = math.hypot(item.get('x', 0.0), item.get('y', 0.0))
        safe_rho = max(rho, 1e-9)
        theta = math.atan2(item.get('y', 0.0), item.get('x', 0.0))
        phi = wrap_angle(theta - beta * math.log(safe_rho))
        scored.append((phi, idx))
    scored.sort(key=lambda pair: pair[0])
    return balanced_groups_from_sorted(scored, frame_count)


def compute_curvature_cascade_groups(items: List[Dict[str, float]], frame_count: int) -> List[List[int]]:
    scored = [(item.get('r', 0.0), idx) for idx, item in enumerate(items)]
    scored.sort(key=lambda pair: pair[0], reverse=True)
    return balanced_groups_from_sorted(scored, frame_count)


def compute_golden_sector_groups(items: List[Dict[str, float]], frame_count: int) -> List[List[int]]:
    scored: List[Tuple[float, int]] = []
    for idx, item in enumerate(items):
        theta = math.atan2(item.get('y', 0.0), item.get('x', 0.0))
        u = mod1(theta / (2 * math.pi))
        h = mod1(u * GOLDEN_RATIO)
        scored.append((h, idx))
    scored.sort(key=lambda pair: pair[0])
    return balanced_groups_from_sorted(scored, frame_count)


def compute_ripple_focus_groups(items: List[Dict[str, float]], frame_count: int, focus: Tuple[float, float]) -> List[List[int]]:
    if frame_count <= 0 or not items:
        return [[] for _ in range(max(frame_count, 0))]
    fx, fy = focus
    groups = [[] for _ in range(frame_count)]
    distances: List[float] = []
    max_dist = 0.0
    for item in items:
        dx = item.get('x', 0.0) - fx
        dy = item.get('y', 0.0) - fy
        dist = math.hypot(dx, dy)
        distances.append(dist)
        if dist > max_dist:
            max_dist = dist
    wavelength = max_dist / max(1, frame_count) if max_dist > 0 else 1.0
    fallback: List[Tuple[float, int]] = []
    for idx, dist in enumerate(distances):
        phase = mod1(dist / max(1e-6, wavelength))
        frame = min(frame_count - 1, int(math.floor(phase * frame_count)))
        groups[frame].append(idx)
        fallback.append((phase, idx))
    if any(len(group) == 0 for group in groups):
        fallback.sort(key=lambda pair: pair[0])
        return balanced_groups_from_sorted(fallback, frame_count)
    return groups


def compute_arm_interleaving_groups(items: List[Dict[str, float]], frame_count: int, beta: float = 1.0) -> List[List[int]]:
    groups = [[] for _ in range(max(frame_count, 0))]
    if frame_count <= 0 or not items:
        return groups
    arms: Dict[int, List[Tuple[int, float]]] = {}
    for idx, item in enumerate(items):
        rho = math.hypot(item.get('x', 0.0), item.get('y', 0.0))
        safe_rho = max(rho, 1e-9)
        theta = math.atan2(item.get('y', 0.0), item.get('x', 0.0))
        u = (theta - beta * math.log(safe_rho)) / (2 * math.pi)
        arm_id = int(round(u))
        arms.setdefault(arm_id, []).append((idx, rho))
    coprime = 1
    if frame_count > 1:
        for candidate in range(1, frame_count):
            if math.gcd(candidate, frame_count) == 1:
                coprime = candidate
                break
    for arm_id, entries in arms.items():
        entries.sort(key=lambda pair: pair[1], reverse=True)
        for order, (idx, _) in enumerate(entries):
            if frame_count == 1:
                groups[0].append(idx)
            else:
                frame = (coprime * order + arm_id) % frame_count
                groups[frame].append(idx)
    if any(len(group) == 0 for group in groups):
        scored: List[Tuple[float, int]] = []
        for entries in arms.values():
            for order, (idx, _) in enumerate(entries):
                scored.append((float(order), idx))
        scored.sort(key=lambda pair: pair[0])
        return balanced_groups_from_sorted(scored, frame_count)
    return groups


def compute_quasi_moire_groups(items: List[Dict[str, float]], frame_count: int, rotate_deg: float = 18.0,
                               sigx: Optional[float] = None, sigy: Optional[float] = None) -> List[List[int]]:
    if frame_count <= 0 or not items:
        return [[] for _ in range(max(frame_count, 0))]
    xs = [item.get('x', 0.0) for item in items]
    ys = [item.get('y', 0.0) for item in items]
    span_x = max(1e-6, max(xs) - min(xs)) if xs else 1.0
    span_y = max(1e-6, max(ys) - min(ys)) if ys else 1.0
    avg_spacing = max((span_x + span_y) / (2 * math.sqrt(len(items) or 1)), 1e-6)
    sigma_x = sigx if sigx and sigx > 0 else span_x / max(2, math.sqrt(frame_count))
    sigma_y = sigy if sigy and sigy > 0 else span_y / max(2, math.sqrt(frame_count))
    ca = math.cos(math.radians(rotate_deg))
    sa = math.sin(math.radians(rotate_deg))
    groups = [[] for _ in range(frame_count)]
    scored: List[Tuple[float, int]] = []
    for idx, item in enumerate(items):
        x = item.get('x', 0.0)
        y = item.get('y', 0.0)
        xr = ca * x - sa * y
        yr = sa * x + ca * y
        u = mod1(xr / max(sigma_x, avg_spacing))
        v = mod1(yr / max(sigma_y, avg_spacing))
        h = mod1(u + math.sqrt(2) * v)
        frame = min(frame_count - 1, int(math.floor(h * frame_count)))
        groups[frame].append(idx)
        scored.append((h, idx))
    if any(len(group) == 0 for group in groups):
        scored.sort(key=lambda pair: pair[0])
        return balanced_groups_from_sorted(scored, frame_count)
    return groups


def compute_animation_frame_assignments(
    items: List[Dict[str, float]],
    angle_step: float,
    pattern_name: str,
    *,
    spiral_center: Optional[Tuple[float, float]] = None,
) -> Tuple[int, Dict[int, int]]:
    item_count = len(items)
    frame_count = derive_frame_count(item_count, angle_step)
    if item_count == 0 or frame_count <= 0:
        return max(0, frame_count), {}

    pattern = (pattern_name or 'ring').lower()
    normalized = [
        {
            'x': float(item.get('x', 0.0)),
            'y': float(item.get('y', 0.0)),
            'r': float(item.get('r', 0.0)),
            'ring_index': int(item.get('ring_index', 0)),
        }
        for item in items
    ]

    grouped: Optional[List[List[int]]] = None
    if pattern in {'ring', 'rings'}:
        grouped = [[] for _ in range(frame_count)]
        for idx, item in enumerate(normalized):
            ring_index = item['ring_index']
            frame = (ring_index % frame_count + frame_count) % frame_count
            grouped[frame].append(idx)
    elif pattern in {'log_spiral', 'log-spiral sweep'}:
        grouped = compute_log_spiral_groups(normalized, frame_count)
    elif pattern in {'curvature_cascade', 'curvature cascade'}:
        grouped = compute_curvature_cascade_groups(normalized, frame_count)
    elif pattern in {'golden_sector', 'golden sector starburst'}:
        grouped = compute_golden_sector_groups(normalized, frame_count)
    elif pattern in {'ripple_focus', 'ripple from focus'}:
        focus = spiral_center if spiral_center is not None else (0.0, 0.0)
        grouped = compute_ripple_focus_groups(normalized, frame_count, focus)
    elif pattern in {'arm_interleaving', 'arm interleaving'}:
        grouped = compute_arm_interleaving_groups(normalized, frame_count)
    elif pattern in {'quasi_moire', 'quasi-moirÃ© stripe scan'}:
        grouped = compute_quasi_moire_groups(normalized, frame_count)

    assignments = groups_to_frame_map(grouped, item_count, frame_count)
    if not assignments:
        return frame_count, sequential_frame_map(item_count, frame_count)
    return frame_count, assignments


# ============================================
# ARC GROUP
# Groups of arcs for outline rendering
# ============================================

class ArcGroup:
    """
    Group of ArcElement objects.

    - An ArcElement can belong to multiple ArcGroups (we store references).
    - We can attempt to produce a closed outline from the group's arcs.
    """
    _id_counter = 0

    def __init__(self, name: Optional[str] = None):
        """
        Initializes an ArcGroup.

        Args:
            name: An optional name for the group.
        """
        ArcGroup._id_counter += 1
        self.id = ArcGroup._id_counter
        self.name = name or f"arcgroup_{self.id}"
        self.arcs: List[ArcElement] = []
        self._arc_points_cache: Dict[ArcElement, List[complex]] = {}
        self._outline_cache: Optional[List[complex]] = None
        # color for debug visualization
        self.debug_fill: Optional[str] = None
        self.debug_stroke: Optional[str] = None
        # public: ring layer index within the Doyle spiral (0-based from smallest radius)
        self.ring_index: Optional[int] = None
        self.base_circle: Optional[CircleElement] = None
        self.animation_frame: Optional[int] = None
        self.line_angle: float = 0.0

    def add_arc(self, arc: ArcElement):
        """
        Adds an ArcElement to the group.

        Args:
            arc: The ArcElement to add.
        """
        self.arcs.append(arc)
        self._cache_arc_points(arc)
        self._invalidate_outline_cache()

    def extend(self, arcs: List[ArcElement]):
        """
        Adds multiple ArcElement objects to the group.

        Args:
            arcs: A list of ArcElement objects to add.
        """
        for arc in arcs:
            self.add_arc(arc)

    def clear(self):
        """
        Removes all arcs from the group.
        """
        self.arcs.clear()
        self._arc_points_cache.clear()
        self._outline_cache = None

    def is_empty(self) -> bool:
        """
        Checks if the group is empty.

        Returns:
            True if the group contains no arcs, False otherwise.
        """
        return len(self.arcs) == 0

    def get_all_points(self) -> List[complex]:
        """
        Return concatenation of point sequences from all arcs (in their stored order).

        Returns:
            A list of complex numbers representing all points from all arcs in the group.
        """
        pts = []
        for arc in self.arcs:
            pts.extend(self._ensure_arc_points(arc))
        return pts

    def _cache_arc_points(self, arc: ArcElement) -> List[complex]:
        """Ensure that the group's cache stores the sampled points for ``arc``."""
        points = arc.get_cached_points()
        if points is None:
            points = arc.get_points()
        self._arc_points_cache[arc] = points
        return points

    def _ensure_arc_points(self, arc: ArcElement) -> List[complex]:
        """Retrieve cached points for ``arc``, populating the cache when necessary."""
        cached_points = self._arc_points_cache.get(arc)
        current_points = arc.get_cached_points()
        if current_points is None:
            current_points = arc.get_points()

        if cached_points is not current_points:
            self._arc_points_cache[arc] = current_points
            self._invalidate_outline_cache()

        return self._arc_points_cache[arc]

    def _invalidate_outline_cache(self):
        """Invalidate the cached outline for the group."""
        self._outline_cache = None

    def get_cached_outline(self) -> Optional[List[complex]]:
        """Return the cached outline if it has been computed."""
        return self._outline_cache

    def _match_points(self, a: complex, b: complex, tol: float = 1e-6) -> bool:
        """
        Checks if two points are approximately the same within a given tolerance.

        Args:
            a: The first point (complex number).
            b: The second point (complex number).
            tol: The tolerance for comparison.

        Returns:
            True if the points are within the tolerance, False otherwise.
        """
        return abs(a - b) <= tol


    def _try_attach_arc(self, ordered_pts, pts, tol):
        """Try to attach arc points to the ordered outline.
        
        Returns:
            Modified ordered_pts if attachment successful, None otherwise.
        """
        start_existing = ordered_pts[0]
        end_existing = ordered_pts[-1]
        start_arc = pts[0]
        end_arc = pts[-1]
        
        # Try appending arc (original direction)
        if self._match_points(end_existing, start_arc, tol):
            return ordered_pts + pts[1:]
        
        # Try appending arc (reversed)
        if self._match_points(end_existing, end_arc, tol):
            return ordered_pts + list(reversed(pts))[1:]
        
        # Try prepending arc (original direction)
        if self._match_points(start_existing, end_arc, tol):
            return pts[:-1] + ordered_pts
        
        # Try prepending arc (reversed)
        if self._match_points(start_existing, start_arc, tol):
            return list(reversed(pts))[:-1] + ordered_pts
        
        return None
    
    def _attach_by_proximity(self, ordered_pts, pts):
        """Attach arc to outline by nearest endpoint."""
        # Calculate distances to front and back of outline
        d_front = min(abs(pts[0] - ordered_pts[0]), abs(pts[-1] - ordered_pts[0]))
        d_back = min(abs(pts[0] - ordered_pts[-1]), abs(pts[-1] - ordered_pts[-1]))
        
        if d_front < d_back:
            # Attach to front
            if abs(pts[-1] - ordered_pts[0]) <= abs(pts[0] - ordered_pts[0]):
                return pts[:-1] + ordered_pts
            else:
                return list(reversed(pts))[:-1] + ordered_pts
        else:
            # Attach to back
            if abs(pts[0] - ordered_pts[-1]) <= abs(pts[-1] - ordered_pts[-1]):
                return ordered_pts + pts[1:]
            else:
                return ordered_pts + list(reversed(pts))[1:]
    
    def get_closed_outline(self, tol: float = 1e-3) -> List[complex]:
        """Order arcs into a closed outline.
        
        Attempts to chain arcs by matching endpoints, reversing when needed.
        Falls back to proximity-based attachment for remaining arcs.
        
        Returns:
            List of points forming the outline (closed if endpoints match).
        """
        if self._outline_cache is not None:
            return list(self._outline_cache)

        if not self.arcs:
            return []

        # Prepare arc entries sorted by point count (longest first)
        entries = [(arc, self._ensure_arc_points(arc)) for arc in self.arcs]
        entries.sort(key=lambda e: -len(e[1]))

        # Start with longest arc
        ordered_pts = entries[0][1].copy()
        used = {0}
        
        # Greedily attach arcs that match endpoints
        while True:
            attached_any = False
            for idx, (arc, pts) in enumerate(entries):
                if idx in used:
                    continue
                
                result = self._try_attach_arc(ordered_pts, pts, tol)
                if result is not None:
                    ordered_pts = result
                    used.add(idx)
                    attached_any = True
                    break
            
            if not attached_any:
                break
        
        # Attach remaining arcs by proximity
        for idx in range(len(entries)):
            if idx not in used:
                ordered_pts = self._attach_by_proximity(ordered_pts, entries[idx][1])
        
        # Close the outline if endpoints match
        if ordered_pts and abs(ordered_pts[0] - ordered_pts[-1]) <= tol:
            ordered_pts[-1] = ordered_pts[0]
        
        self._outline_cache = ordered_pts.copy()
        return ordered_pts

    def to_svg_fill(self, context: DrawingContext, debug: bool = False, fill_opacity: float = 0.25, pattern_fill: bool = False, line_settings = (2,0), use_clipped_lines: bool = True, draw_outline: bool = True, line_offset: float = 0):
        """
        Render group outline as filled polygon if closed (or as polyline) for debug.

        The context expects unscaled points; we will scale them with context.scale_factor.

        Args:
            context: The DrawingContext to use for rendering.
            debug: Whether to render with debug colors (fill and stroke).
            fill_opacity: The opacity of the fill when debug is True.
            pattern_fill: Whether to use pattern/line fill.
            line_settings: Tuple of (spacing, angle) for line patterns.
            use_clipped_lines: If True, use actual clipped lines instead of SVG patterns (default: True).
            draw_outline: If True, draw the polygon outline (default: True).
            line_offset: Inset distance from polygon edge for line clipping (positive = shrink inward).
        """
        # Get the points for the outline
        pts = self.get_closed_outline()
        if not pts:
            return
        # scale points using the drawing context's scale factor
        scaled = [p * context.scale_factor for p in pts]
        if debug:
            # Generate a random color if debug colors are not set
            fill = self.debug_fill or "#%06x" % random.randint(0, 0xFFFFFF)
            stroke = self.debug_stroke or "#000000"
            # set fill and stroke and draw as a polygon
            context.draw_group_outline(scaled, fill=fill, stroke=stroke, stroke_width=0.8)
        elif pattern_fill:
            stroke = self.debug_stroke or "#000000"
            context.draw_group_outline(scaled, fill="pattern", stroke=stroke, stroke_width=0.8, 
                                      line_pattern_settings=line_settings, use_clipped_lines=use_clipped_lines,
                                      draw_outline=draw_outline, line_offset=line_offset)
        else:
            # Only draw outline if draw_outline is explicitly True when pattern_fill is False
            if draw_outline:
                context.draw_group_outline(scaled, fill=None, stroke="#000000", stroke_width=0.6)

# ============================================
# Doyle Spiral Class
# ============================================

class DoyleSpiral:
    """Manages the generation, intersection, and rendering of a Doyle spiral."""
    def __init__(self, p: int = 7, q: int = 32, t: float = 0, max_d: float = 2000, arc_mode: str = "closest", num_gaps: int = 2):
        """
        Initializes a DoyleSpiral.

        Args:
            p: The p parameter for the spiral.
            q: The q parameter for the spiral.
            t: The t parameter for the spiral.
            max_d: The maximum distance from the center for generating circles.
            arc_mode: The mode for selecting arcs ('closest', 'farthest', 'alternating', 'all', 'random', 'symmetric', 'angular').
            num_gaps: The number of "gaps" or arcs not to draw in 'arram_boyle' mode.
        """
        self.p, self.q, self.t, self.max_d = p, q, t, max_d
        self.arc_mode = arc_mode
        self.num_gaps = num_gaps
        # Solve the underlying Doyle system for the given parameters
        self.root = DoyleMath.solve(p, q)
        self.circles: List[CircleElement] = []
        self.outer_circles: List[CircleElement] = []
        self._is_generated = False

        # ArcGroups keyed by circle id or arbitrary name
        self.arc_groups: Dict[str, ArcGroup] = {}
        self.fill_pattern_angle: float = 0.0

    def generate_circles(self):
        """Generates the main set of visible circles based on the spiral parameters."""
        # Extract parameters from the Doyle solution
        r = self.root["r"]
        start = self.root["a"]
        scale = self.root["mod_a"] ** self.t
        alpha = self.root["arg_a"] * self.t
        min_d = 1 / scale
        a, b = self.root["a"], self.root["b"]
        w = np.exp(1j * alpha)

        circles = []
        # Generate q families of circles
        for _ in range(1, self.q + 1):
            # Generate circles moving outward from the center
            qv = start
            mod_q = abs(qv)
            while mod_q < self.max_d:
                center = scale * qv * w
                circles.append(CircleElement(center, r * scale * mod_q))
                qv *= a
                mod_q *= abs(a)

            # Generate circles moving inward towards the center
            qv = start / a # Start one step inward from the base
            mod_q = abs(qv)
            while mod_q > min_d:
                center = scale * qv * w
                circles.append(CircleElement(center, r * scale * mod_q))
                qv /= a
                mod_q /= abs(a)

            # Move to the next family of circles
            start *= b

        self.circles = circles
        self._is_generated = True

    def generate_outer_circles(self):
        """Generates exactly one outer ring of invisible circles for Arram-Boyle closure."""
        r = self.root["r"]
        start = self.root["a"]
        scale = self.root["mod_a"] ** self.t
        alpha = self.root["arg_a"] * self.t
        a, b = self.root["a"], self.root["b"]
        w = np.exp(1j * alpha)

        outer_circles = []
        # Generate one outer circle for each of the q families
        for _ in range(1, self.q + 1):
            qv = start
            # Fast-forward to the last generated visible circle's 'qv'
            while abs(qv) * scale < self.max_d:
                qv *= a

            # Add exactly one more circle (the next one outward)
            center = scale * qv * w
            # Use a generous multiplier for max_d check to ensure we get the next ring
            if abs(qv) * scale < self.max_d * abs(a) * 2:
                outer_circles.append(CircleElement(center, r * scale * abs(qv), visible=False))

            start *= b

        self.outer_circles = outer_circles

    def compute_all_intersections(self):
        """Computes all intersections for visible and outer circles."""
        all_circles = self.circles + self.outer_circles
        if not all_circles:
            return

        centers = np.array([[c.center.real, c.center.imag] for c in all_circles], dtype=float)
        radii = np.array([c.radius for c in all_circles], dtype=float)
        tree = cKDTree(centers)
        max_radius = float(radii.max())
        tol = 1e-3

        for idx, circle in enumerate(all_circles):
            query_radius = circle.radius + max_radius + tol
            candidate_indices = tree.query_ball_point(centers[idx], query_radius)
            candidates = []
            for j in candidate_indices:
                if j == idx:
                    continue
                other = all_circles[j]
                if abs(circle.center - other.center) <= circle.radius + other.radius + tol:
                    candidates.append(other)

            # All circles need the spiral center (0+0j) as the reference for sorting
            circle.compute_intersections(candidates, start_reference=0+0j, tol=tol)

    # ---- ArcGroup management APIs ----
    def create_group_for_circle(self, circle: CircleElement, name: Optional[str] = None) -> ArcGroup:
        """
        Create an ArcGroup for a specific circle.

        Args:
            circle: The CircleElement for which to create the group.
            name: An optional name for the group. If None, a name based on the circle ID is used.

        Returns:
            The created ArcGroup object.
        """
        key = name or f"circle_{circle.id}"
        group = ArcGroup(name=key)
        group.base_circle = circle
        self.arc_groups[key] = group
        return group

    def add_arc_to_group(self, group_key: str, arc: ArcElement):
        """
        Add an ArcElement to an existing group (or create group if missing).

        Args:
            group_key: The key/name of the ArcGroup.
            arc: The ArcElement to add to the group.
        """
        if group_key not in self.arc_groups:
            self.arc_groups[group_key] = ArcGroup(name=group_key)
        self.arc_groups[group_key].add_arc(arc)

    # ---- Rendering Helpers ----
    
    def _compute_ring_indices(self):
        """Compute ring index mapping based on circle radii."""
        radii = [round(c.radius, 6) for c in self.circles]
        unique_radii = sorted(set(radii))
        return {r: i for i, r in enumerate(unique_radii)}
    
    def _create_arc_groups_for_circles(self, radius_to_ring, spiral_center, debug_groups, 
                                       add_fill_pattern, draw_group_outline, context):
        """Create arc groups for visible circles and draw individual arcs."""
        for c in self.circles:
            if len(c.intersections) != 6:
                continue
            
            # Select arcs based on mode
            arcs_to_draw = ArcSelector.select_arcs_for_gaps(
                c, spiral_center, num_gaps=self.num_gaps, mode=self.arc_mode
            )
            if not arcs_to_draw:
                continue
            
            # Create group for this circle
            group = self.create_group_for_circle(c)
            group.ring_index = radius_to_ring.get(round(c.radius, 6), None)
            
            # Assign debug color if needed
            if debug_groups:
                rng = random.Random(c.id)
                group.debug_fill = "#%06x" % rng.randint(0, 0xFFFFFF)
                group.debug_stroke = "#000000"
            
            # Create and add arcs to group
            for i, j in arcs_to_draw:
                start = c.intersections[i][0]
                end = c.intersections[j][0]
                arc = ArcElement(c, start, end, visible=True)
                
                # Draw arc only if not using fill pattern and outline enabled
                if not add_fill_pattern and draw_group_outline:
                    context.draw_scaled(arc)
                
                group.add_arc(arc)
    
    def _draw_outer_closure_arcs(self, spiral_center, debug_groups, red_outline, 
                                 add_fill_pattern, draw_group_outline, context):
        """Draw closure arcs from outer invisible circles."""
        for c in self.outer_circles:
            if len(c.intersections) < 2:
                continue
            
            pts = [p for p, _ in c.intersections]
            arc_distances = []
            
            # Calculate arc midpoint distances to center
            for i in range(len(pts)):
                j = (i + 1) % len(pts)
                midpoint = (pts[i] + pts[j]) / 2
                arc_distances.append((abs(midpoint - spiral_center), i, j))
            
            # Draw 2nd and 3rd closest arcs
            arc_distances.sort()
            for idx in range(1, min(3, len(arc_distances))):
                _, i, j = arc_distances[idx]
                arc = ArcElement(c, pts[i], pts[j], visible=True)
                
                # Draw if red outline enabled or (no fill and outline enabled)
                if red_outline or (not add_fill_pattern and draw_group_outline):
                    color = "#ff0000" if red_outline else "#000000"
                    context.draw_scaled(arc, color=color, width=1.2)
                
                # Add to outer closure group
                key = f"outer_{c.id}"
                if key not in self.arc_groups:
                    self.arc_groups[key] = ArcGroup(name=key)
                    self.arc_groups[key].ring_index = -1
                    if debug_groups:
                        rng = random.Random(c.id + 1000)
                        self.arc_groups[key].debug_fill = "#%06x" % rng.randint(0, 0xFFFFFF)
                        self.arc_groups[key].debug_stroke = "#000000"
                
                self.arc_groups[key].add_arc(arc)
    
    # ---- Rendering ----

    def _render_arram_boyle(self, context: DrawingContext, debug_groups: bool = False,
                           add_fill_pattern: bool = False, fill_pattern_spacing: float = 5.0,
                           fill_pattern_angle: float = 0.0, red_outline: bool = False,
                           draw_group_outline: bool = True, fill_pattern_offset: float = 0,
                           fill_pattern_animation: str = "ring"):
        """Render spiral in Arram-Boyle mode with arc groups.
        
        Creates arc groups for each circle, draws closure arcs, and optionally
        adds pattern fills or debug visualization.
        """
        # Setup
        self.generate_outer_circles()
        self.compute_all_intersections()
        context.set_normalization_scale(self.circles + self.outer_circles)

        self.fill_pattern_angle = fill_pattern_angle
        self.fill_pattern_animation = fill_pattern_animation
        
        spiral_center = 0 + 0j
        self.arc_groups.clear()
        
        # Compute ring indices for all circles
        radius_to_ring_index = self._compute_ring_indices()
        
        # Create arc groups for visible circles
        self._create_arc_groups_for_circles(
            radius_to_ring_index, spiral_center, debug_groups,
            add_fill_pattern, draw_group_outline, context
        )
        
        # Draw outer closure arcs
        self._draw_outer_closure_arcs(
            spiral_center, debug_groups, red_outline,
            add_fill_pattern, draw_group_outline, context
        )
        
        #"""
        # complete arc groups - This block appears to add additional arcs based on neighbor circles
        # and specific indices. This might require further review for its geometric purpose.
        max_index = max([group.ring_index for group in self.arc_groups.values()])
        for c in self.circles:
            if not f"circle_{c.id}" in self.arc_groups.keys(): continue
            group = self.arc_groups[f"circle_{c.id}"]
            neigh_lst = c.get_neighbour_circles()
            if len(neigh_lst) == 6:
                for k in [-1,-2,-5,-6]: #[0,-1,2,3]: # Indices to select neighbors
                    neigh_a = neigh_lst[k]
                    # Select all arcs from the neighbor circle
                    arcs_a = ArcSelector.select_arcs_for_gaps(neigh_a, spiral_center, mode="all")
                    #print(len(arcs_a)) # Debug print, can be removed
                    if len(arcs_a) == 6:
                        # Select specific arc index based on neighbor index k
                        arc_i = 0
                        if k == -1: arc_i = -3
                        if k == -2: arc_i = -2
                        if k == -5: arc_i = 1
                        if k == -6: arc_i = 0
                        i,j = arcs_a[arc_i]
                        # Get start and end points from the neighbor circle's intersections
                        start_a = neigh_a.intersections[i][0]
                        end_a = neigh_a.intersections[j][0]
                        # Create a new arc element from the neighbor circle
                        arc_a = ArcElement(neigh_a, start_a, end_a, visible=True)
                        # Add this arc to the current circle's group

                        group.add_arc(arc_a)
                    else:
                        # Similar logic for neighbors with a different number of arcs
                        arc_i = 0
                        if k == -1: arc_i = -3
                        if k == -2: arc_i = -2
                        if k == -5: arc_i = 1
                        if k == -6: arc_i = 0
                        i,j = arcs_a[arc_i]
                        start_a = neigh_a.intersections[i][0]
                        end_a = neigh_a.intersections[j][0]
                        arc_a = ArcElement(neigh_a, start_a, end_a, visible=True)
                        group.add_arc(arc_a)
        
        #"""
        # After drawing all arcs, render group outlines (debug fills) if debug is enabled
        if debug_groups:
            for key, group in self.arc_groups.items():
                # Exclude outer circle groups from default debug rendering
                if "outer" in key: continue
                # render group fill/outline
                group.to_svg_fill(context, debug=True, fill_opacity=0.25)

        # Prepare animation assignments for fill rotation and playback
        active_entries = []
        for key, group in self.arc_groups.items():
            if "outer" in key:
                continue
            base_circle = group.base_circle
            if base_circle is None and group.arcs:
                base_circle = group.arcs[0].circle
            if base_circle is None:
                continue
            center = base_circle.center
            active_entries.append({
                'group': group,
                'ring_index': group.ring_index if group.ring_index is not None else 0,
                'x': center.real,
                'y': center.imag,
                'r': base_circle.radius,
            })

        animation_items = [
            {
                'x': entry['x'],
                'y': entry['y'],
                'r': entry['r'],
                'ring_index': entry['ring_index'],
            }
            for entry in active_entries
        ]
        frame_count, assignments = compute_animation_frame_assignments(
            animation_items,
            fill_pattern_angle,
            fill_pattern_animation,
            spiral_center=(0.0, 0.0),
        )
        safe_frame_count = max(1, frame_count)
        self.animation_frame_count = safe_frame_count

        for idx, entry in enumerate(active_entries):
            group = entry['group']
            fallback_frame = (entry['ring_index'] % safe_frame_count + safe_frame_count) % safe_frame_count
            assigned_frame = assignments.get(idx)
            frame = assigned_frame if isinstance(assigned_frame, int) else fallback_frame
            angle = frame * fill_pattern_angle
            group.animation_frame = frame
            group.line_angle = angle

        #"""
        # After drawing all arcs, render line fillings
        if add_fill_pattern:
            for key, group in self.arc_groups.items():
                # Exclude outer circle groups from default debug rendering
                if "outer" in key: continue
                # render group fill/outline
                #group.to_svg_fill(context, debug=True, fill_opacity=0.25)
                # Interpret fill_pattern_angle as per-ring angle offset (degrees)
                ring_idx = group.ring_index if group.ring_index is not None else 0
                line_angle = group.line_angle if isinstance(group.line_angle, (int, float)) else ring_idx * fill_pattern_angle
                line_settings = (fill_pattern_spacing, line_angle)
                group.to_svg_fill(context, debug=False, fill_opacity=0.25, pattern_fill=True, line_settings=line_settings, draw_outline=draw_group_outline, line_offset=fill_pattern_offset)

        #draw red outline if option is set
        for c in self.circles:
            if not f"circle_{c.id}" in self.arc_groups.keys(): continue
            group = self.arc_groups[f"circle_{c.id}"]
            
            for i, arc in enumerate(group.arcs):
                if red_outline and (i in [3,2]) and group.ring_index == max_index: 
                    color = "#ff0000"
                    context.draw_scaled(arc, color=color, width=1.2)

        # ring_index has been assigned at creation time for inner groups and -1 for outer groups


    def _render_doyle(self, context: DrawingContext):
        """Handles the standard Doyle rendering mode (full circles)."""
        # Set normalization scale based on visible circles
        context.set_normalization_scale(self.circles)
        # Draw all visible circles
        for c in self.circles:
            context.draw_scaled(c)  # Use default circle color


    def to_svg(self, mode: str = "doyle", size: int = 800, debug_groups: bool = False, add_fill_pattern: bool = False,
               fill_pattern_spacing: float = 5.0, fill_pattern_angle: float = 0.0, red_outline: bool = False,
               draw_group_outline: bool = True, fill_pattern_offset: float = 0, fill_pattern_animation: str = "ring") -> str:
        """
        Generates the SVG representation of the spiral in the specified mode.

        Args:
            mode: The rendering mode ('doyle' for full circles, 'arram_boyle' for arcs).
            size: The size of the output SVG (width and height).
            debug_groups: If True, render arc group outlines with debug colors in 'arram_boyle' mode.
            add_fill_pattern: If True, add line pattern fills to arc groups.
            fill_pattern_spacing: Spacing between lines in the pattern.
            fill_pattern_angle: Angle increment per ring for line patterns.
            red_outline: If True, draw red outline on specific arcs.
            draw_group_outline: If True, draw the arc group polygon outlines (default: True).
            fill_pattern_offset: Inset distance from polygon edge for line clipping (positive = shrink inward).
            fill_pattern_animation: Name of the animation pattern used to assign frame/angle offsets.

        Returns:
            A string containing the SVG representation of the spiral.

        Raises:
            ValueError: If an unknown rendering mode is provided.
        """
        # Generate circles if not already generated
        if not self._is_generated:
            self.generate_circles()

        # Create a drawing context
        context = DrawingContext(size)

        # Render based on the selected mode
        if mode == "doyle":
            self._render_doyle(context)
        elif mode == "arram_boyle":
            self._render_arram_boyle(
                context,
                debug_groups=debug_groups,
                add_fill_pattern=add_fill_pattern,
                fill_pattern_spacing=fill_pattern_spacing,
                fill_pattern_angle=fill_pattern_angle,
                red_outline=red_outline,
                draw_group_outline=draw_group_outline,
                fill_pattern_offset=fill_pattern_offset,
                fill_pattern_animation=fill_pattern_animation,
            )
        else:
            raise ValueError(f"Unknown rendering mode: {mode}")

        # Return the SVG as a string
        return context.to_string()

    def to_json_dict(self) -> Dict[str, object]:
        """Return a serialisable dictionary describing the current arc groups.

        The dictionary mirrors the structure previously written by
        :meth:`export_to_json`, exposing spiral parameters together with the
        outlines and metadata for each visible arc group.

        Returns:
            Dict[str, object]: A JSON-ready dictionary describing the spiral.

        Raises:
            RuntimeError: If arc groups have not been generated yet. Render the
                spiral in ``arram_boyle`` mode first to populate them.
        """
        if not self.arc_groups:
            raise RuntimeError("No arc groups to export. Run to_svg() with 'arram_boyle' mode first.")

        export_data: Dict[str, object] = {
            "spiral_params": {
                "p": self.p,
                "q": self.q,
                "t": self.t,
                "max_d": self.max_d,
                "arc_mode": self.arc_mode,
                "num_gaps": self.num_gaps,
            },
            "arcgroups": [],
            "animation": {
                "pattern": getattr(self, "fill_pattern_animation", "ring"),
                "frame_count": getattr(self, "animation_frame_count", 0),
            },
        }

        for group_key, group in self.arc_groups.items():
            if "outer" in group_key:
                continue

            outline = group.get_cached_outline()
            if outline is None:
                computed_outline = group.get_closed_outline()
                outline = group.get_cached_outline()
                if outline is None:
                    outline = computed_outline

            outline_points = [[p.real, p.imag] for p in outline] if outline else []

            ring_index = group.ring_index if group.ring_index is not None else 0
            line_angle = group.line_angle if isinstance(group.line_angle, (int, float)) else ring_index * self.fill_pattern_angle
            animation_frame = group.animation_frame if isinstance(group.animation_frame, int) else None

            export_data["arcgroups"].append({
                "id": group.id,
                "name": group.name,
                "ring_index": group.ring_index,
                "line_angle": line_angle,
                "outline": outline_points,
                "arc_count": len(group.arcs),
                "animation_frame": animation_frame,
            })

        return export_data

    def export_to_json(self, filename: str = 'doyle_spiral.json'):
        """
        Exports the spiral's arc groups to a JSON file.

        Preserves arcgroup data including outlines, ring indices, and line angles.

        Args:
            filename: Output filename for the JSON file.
        """
        try:
            export_data = self.to_json_dict()
        except RuntimeError as exc:
            print(str(exc))
            return

        try:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(export_data, f, indent=2)
            print(f"â Spiral exported successfully to '{filename}'")
            print(f"   - {len(export_data['arcgroups'])} arc groups")
        except Exception as e:
            print(f"â Error exporting spiral: {e}")

# ============================================
# Doyle Math and Arc Selection
# ============================================

class DoyleMath:
    """Static methods for solving the Doyle spiral system."""
    @staticmethod
    def d_(z: float, t: float, p: int, q: int) -> float:
        # Helper function for the Doyle equation
        w = z ** (p / q)
        s = (p * t + 2 * np.pi) / q
        return (z * np.cos(t) - w * np.cos(s))**2 + (z * np.sin(t) - w * np.sin(s))**2

    @staticmethod
    def s_(z: float, p: int, q: int) -> float:
        # Helper function for the Doyle equation
        return (z + z ** (p / q)) ** 2

    @staticmethod
    def r_(z: float, t: float, p: int, q: int) -> float:
        # Helper function for the Doyle equation
        return DoyleMath.d_(z, t, p, q) / DoyleMath.s_(z, p, q)

    @staticmethod
    def solve(p: int, q: int) -> dict:
        """
        Solves the Doyle system for a given (p, q).

        Args:
            p: The p parameter of the Doyle spiral.
            q: The q parameter of the spiral.

        Returns:
            A dictionary containing the solution parameters 'a', 'b', 'r', 'mod_a', and 'arg_a'.
        """
        # Define the system of equations to solve
        def f_(x: np.ndarray) -> List[float]:
            z, t = x
            f1 = DoyleMath.r_(z, t, 0, 1) - DoyleMath.r_(z, t, p, q)
            f2 = DoyleMath.r_(z, t, 0, 1) - DoyleMath.r_(z ** (p / q), (p * t + 2 * np.pi) / q, 0, 1)
            return [f1, f2]

        # Use scipy's root finder to solve the system
        sol = root(f_, [2.0, 0.0], tol=1e-6)
        z, t = sol.x
        # Calculate spiral parameters from the solution
        r = np.sqrt(DoyleMath.r_(z, t, 0, 1))
        a = z * np.exp(1j * t)
        b = z ** (p / q) * np.exp(1j * (p * t + 2 * np.pi) / q)
        return {"a": a, "b": b, "r": r, "mod_a": z, "arg_a": t}

class ArcSelector:
    """Static methods for selecting which arcs to draw based on a mode."""
    @staticmethod
    def select_arcs_for_gaps(
        circle: CircleElement,
        spiral_center: complex,
        num_gaps: int = 2,
        mode: str = "closest"
    ) -> List[Tuple[int, int]]:
        """
        Selects arcs from a circle based on geometric or heuristic rules.
        Returns a list of arc index pairs (start_idx, end_idx) to be drawn.

        Args:
            circle: The CircleElement from which to select arcs.
            spiral_center: The center of the Doyle spiral (used as a reference point).
            num_gaps: The number of "gaps" or arcs *not* to draw.
            mode: The selection mode ('closest', 'farthest', 'alternating', 'all', 'random', 'symmetric', 'angular').

        Returns:
            A list of tuples, where each tuple represents the start and end index of an arc to be drawn,
            based on the sorted intersection points of the circle.
        """
        # Get intersection points from the circle
        pts = [p for p, _ in circle.intersections]
        n = len(pts)
        c = circle.center # Center of the current circle
        s = spiral_center # Center of the spiral

        if n < 2:
            return []

        # Create pairs of indices representing potential arcs between consecutive intersection points
        arcs = [(i, (i + 1) % n) for i in range(n)]
        # Calculate midpoints of these potential arcs
        midpoints = [(pts[i] + pts[j]) / 2 for i, j in arcs]

        # Select arcs based on the specified mode
        if mode in ("closest", "farthest"):
            # Calculate distances of arc midpoints to the line connecting circle center and spiral center
            line_vec = s - c
            # Handle the case where the line vector is zero (circle center is spiral center)
            if abs(line_vec) < 1e-6:
                 # In this case, all distances to the line are effectively zero.
                 # Sort by distance from the spiral center directly.
                 distances = [abs(m - s) for m in midpoints]
            else:
                 distances = [abs(np.imag(np.conj(line_vec) * (m - c))) / abs(line_vec) for m in midpoints]

            # Sort arcs based on distance, reverse if mode is 'farthest'
            sorted_arcs = [arc for _, arc in sorted(zip(distances, arcs), reverse=(mode == "farthest"))]
            # Select arcs to draw (skip the ones creating gaps)
            arcs_to_draw = sorted_arcs[num_gaps:]

        elif mode == "alternating":
            # Select arcs in an alternating pattern
            if num_gaps >= n:
                return [] # Skip all if num_gaps is greater than or equal to number of arcs
            # Determine the interval for skipping
            interval = max(1, n // (num_gaps + 1))
            arcs_to_draw = [arcs[i] for i in range(n) if (i % (interval)) != 0]

        elif mode == "all":
            # Select all arcs
            arcs_to_draw = arcs
        elif mode == "random":
            # Randomly select arcs to skip
            rng = np.random.default_rng()
            skip_idxs = rng.choice(range(n), size=min(num_gaps, n), replace=False)
            arcs_to_draw = [arc for i, arc in enumerate(arcs) if i not in skip_idxs]

        elif mode == "symmetric":
            # Select symmetric gaps around the line to the spiral center
            line_vec = s - c
             # Handle the case where the line vector is zero (circle center is spiral center)
            if abs(line_vec) < 1e-6:
                 # In this case, all angles are relative to the center, sort by angle from the x-axis
                 angles = [np.angle(m - c) for m in midpoints]
                 target_angle = 0 # Reference angle is along the positive x-axis
            else:
                angles = [np.angle(m - c) for m in midpoints]
                target_angle = np.angle(s - c)

            angular_diffs = [abs(np.angle(np.exp(1j * (a - target_angle)))) for a in angles]
            sorted_indices = np.argsort(angular_diffs)

            # Choose indices for half the gaps
            num_half_gaps = num_gaps // 2
            chosen = sorted_indices[:num_half_gaps]

            # Find symmetric indices - this needs to be relative to the circle's intersections, not angle directly
            # Find the intersection points closest to the line (which correspond to the smallest angular_diffs)
            # Then find the points roughly 180 degrees around the circle from those points.
            skip_indices = set()
            for idx in chosen:
                skip_indices.add(idx) # Add the original index
                # Find the intersection point corresponding to this midpoint arc
                midpoint_pt = midpoints[idx]
                # Find the index of the intersection point that is roughly 180 degrees opposite on the circle
                opposite_angle = np.angle(midpoint_pt - c) + np.pi
                opposite_index = -1
                min_angle_diff = float('inf')
                for i in range(n):
                    pt_angle = np.angle(pts[i] - c)
                    diff = abs(np.angle(np.exp(1j * (pt_angle - opposite_angle))))
                    if diff < min_angle_diff:
                        min_angle_diff = diff
                        opposite_index = i
                # The arc starting at the opposite_index is the symmetric one
                symmetric_arc_start_index = opposite_index
                # Find which arc index starts at symmetric_arc_start_index
                for i, (start, end) in enumerate(arcs):
                    if start == symmetric_arc_start_index:
                         # Add the arc index (not the intersection point index) to the skip list
                         skip_indices.add(i)
                         break

            # If num_gaps is odd, and the circle has an intersection point very close to the line,
            # we skip the arc that crosses the line.
            if num_gaps % 2 != 0 and abs(line_vec) > 1e-6:
                 # Find the intersection point closest to the line
                 intersection_distances = [abs(np.imag(np.conj(line_vec) * (p - c))) / abs(line_vec) for p, _ in circle.intersections]
                 closest_intersection_idx = np.argmin(intersection_distances)
                 # The arc that crosses the line is likely the one starting at or ending at this point
                 # We'll skip the arc starting at this point
                 for i, (start, end) in enumerate(arcs):
                     if start == closest_intersection_idx:
                         skip_indices.add(i)
                         break

            # Select arcs to draw
            arcs_to_draw = [arc for i, arc in enumerate(arcs) if i not in skip_indices]


        elif mode == "angular":
            # Select arcs based on angular distance from the line to the spiral center
            line_vec = s - c
             # Handle the case where the line vector is zero (circle center is spiral center)
            if abs(line_vec) < 1e-6:
                 # In this case, all angles are relative to the center, sort by angle from the x-axis
                 angles = [np.angle(m - c) for m in midpoints]
                 target_angle = 0 # Reference angle is along the positive x-axis
            else:
                angles = [np.angle(m - c) for m in midpoints]
                target_angle = np.angle(s - c)

            angular_diffs = [abs(np.angle(np.exp(1j * (a - target_angle)))) for a in angles]
            # Sort arcs by angular difference
            sorted_arcs = [arc for _, arc in sorted(zip(angular_diffs, arcs))]
            # Select arcs to draw (skip the ones creating gaps)
            arcs_to_draw = sorted_arcs[num_gaps:]

        else:
            raise ValueError(f"Unknown mode '{mode}'")

        return arcs_to_draw

# ============================================
# Interactive UI
# ============================================

def spiral_ui():
    """
    Sets up the interactive UI for the Doyle Spiral with debug toggle for ArcGroups.

    Creates sliders and dropdowns for controlling spiral parameters and rendering mode,
    and displays the generated SVG. Includes controls for manually adding arcs to groups.
    """
    # Create interactive widgets for controlling spiral parameters and rendering
    p = widgets.IntSlider(value=16, min=2, max=64, step=1, description='p')
    q = widgets.IntSlider(value=16, min=4, max=128, step=1, description='q')
    t = widgets.FloatSlider(value=0, min=0, max=1, step=0.05, description='t')
    mode = widgets.Dropdown(options=['doyle', 'arram_boyle'], value='arram_boyle', description='Mode')
    arc_mode = widgets.Dropdown(options=['closest', 'farthest', 'alternating', 'all', 'random', 'symmetric', 'angular'], value='closest', description='Arc Mode')
    num_gaps = widgets.IntSlider(value=2, min=0, max=6, step=1, description='Num Gaps')
    debug = widgets.Checkbox(value=False, description="Debug: color arc groups")
    red_outline = widgets.Checkbox(value=False, description="Red outline: color outline")
    # Pattern fill UI controls
    add_fill_pattern = widgets.Checkbox(value=False, description='Add fill pattern')
    fill_pattern_spacing = widgets.FloatSlider(value=5.0, min=0.5, max=20.0, step=0.5, description='Line spacing')
    fill_pattern_angle = widgets.FloatSlider(value=0.0, min=-90.0, max=90.0, step=1.0, description='Angle (deg)')
    fill_pattern_offset = widgets.FloatSlider(value=0.0, min=0.0, max=10.0, step=0.5, description='Line offset')
    draw_group_outline = widgets.Checkbox(value=True, description='Draw group outline')
    
    # Save controls
    filename_input = widgets.Text(value='doyle_spiral.svg', description='Filename:', placeholder='Enter filename')
    save_button = widgets.Button(description='Save SVG', button_style='success', icon='save')
    save_output = widgets.Output()
    
    out = widgets.Output() # Output widget to display the SVG and messages

    # Hold a spiral instance and svg data so they can be accessed by save function
    spiral_holder: Dict[str, Optional[DoyleSpiral]] = {"spiral": None, "svg_data": None}

    def render(_=None):
        """
        Renders the Doyle spiral based on the current widget values and displays the SVG.

        This function is called whenever a widget value changes.
        """
        with out:
            clear_output(wait=True) # Clear previous output
            # Create a new spiral instance on change to ensure clean state
            spiral = DoyleSpiral(p.value, q.value, t.value, arc_mode=arc_mode.value, num_gaps=num_gaps.value)
            spiral_holder["spiral"] = spiral # Store the current spiral instance
            try:
                # Generate SVG based on selected mode and debug option
                svg_data = spiral.to_svg(
                    mode.value,
                    debug_groups=debug.value,
                    add_fill_pattern=add_fill_pattern.value,
                    fill_pattern_spacing=fill_pattern_spacing.value,
                    fill_pattern_angle=fill_pattern_angle.value,
                    red_outline=red_outline.value,
                    draw_group_outline=draw_group_outline.value,
                    fill_pattern_offset=fill_pattern_offset.value
                )
                spiral_holder["svg_data"] = svg_data  # Store SVG data for saving
                display(SVG(svg_data)) # Display the generated SVG
                # After rendering, print group info for debugging if debug is enabled
                if debug.value:
                    print(f"ArcGroups created: {list(spiral.arc_groups.keys())}")
                    for k, g in spiral.arc_groups.items():
                        print(f" - {k}: {len(g.arcs)} arcs")
            except Exception as e:
                print(f"Error generating SVG: {e}") # Print error message if SVG generation fails

    def save_svg(_=None):
        """
        Saves the current SVG to a file with the user-specified filename.
        
        This function is called when the save button is clicked.
        """
        with save_output:
            clear_output(wait=True)
            svg_data = spiral_holder.get("svg_data")
            if svg_data is None:
                print("â ï¸ No SVG to save. Please render the spiral first.")
                return
            
            filename = filename_input.value.strip()
            if not filename:
                print("â ï¸ Please enter a filename.")
                return
            
            # Add .svg extension if not present
            if not filename.endswith('.svg'):
                filename += '.svg'
            
            try:
                with open(filename, "w", encoding="utf-8") as f:
                    f.write(svg_data)
                print(f"â SVG saved successfully as '{filename}'")
            except Exception as e:
                print(f"â Error saving SVG: {e}")

    def save_json(_=None):
        """Saves the current spiral to JSON format."""
        with save_output:
            clear_output(wait=True)
            spiral = spiral_holder.get("spiral")
            if spiral is None:
                print("â ï¸ No spiral to save. Please render first.")
                return
            
            filename = filename_json_input.value.strip()
            if not filename:
                print("â ï¸ Please enter a filename.")
                return
            
            if not filename.endswith('.json'):
                filename += '.json'
            
            spiral.export_to_json(filename)
        
        # Wire up the save button
        save_button.on_click(save_svg)

    #json export controls
    filename_json_input = widgets.Text(value='doyle_spiral.json', description='JSON Filename:', placeholder='Enter filename')
    save_json_button = widgets.Button(description='Save JSON', button_style='info', icon='save')
    save_json_button.on_click(save_json)

    # Wire up observers / callbacks: call the render function when widget values change
    for w in [p, q, t, mode, arc_mode, num_gaps, debug, add_fill_pattern, fill_pattern_spacing, fill_pattern_angle, fill_pattern_offset, red_outline, draw_group_outline]:
        w.observe(render, names="value")

    # Initial render when the UI is first displayed
    render()

    # Arrange the widgets in a vertical box
    controls_top = widgets.HBox([p, q, t, mode])
    controls_arc = widgets.HBox([arc_mode, num_gaps, debug, red_outline])
    controls_fill = widgets.HBox([add_fill_pattern, fill_pattern_spacing, fill_pattern_angle, fill_pattern_offset, draw_group_outline])
    controls_save = widgets.HBox([filename_input, save_button, filename_json_input, save_json_button])
    display(widgets.VBox([controls_top, controls_arc, controls_fill, controls_save, save_output, out]))

