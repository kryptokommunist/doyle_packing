# -*- coding: utf-8 -*-
"""golden spiral

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ge2j9ls2mRCKHBBLcdP5YlZUPbWngI2F
"""

import numpy as np
from scipy.optimize import root
import svgwrite
from typing import List, Tuple, Optional, Set, Dict
import random
import math
import itertools
from matplotlib.path import Path as MplPath

# ============================================
# Base Geometry and Drawing Classes
# ============================================

class Shape:
    """Base class for geometric shapes."""
    def __init__(self, visible: bool = True):
        """
        Initializes a Shape object.

        Args:
            visible: Whether the shape should be visible in the drawing.
        """
        self.visible = visible

    def to_svg(self, dwg: svgwrite.Drawing):
        """
        Abstract method to render the shape to an SVG element.

        Args:
            dwg: The svgwrite Drawing object.

        Raises:
            NotImplementedError: This method must be implemented by subclasses.
        """
        raise NotImplementedError

# ============================================
# GEOMETRY UTILITIES
# Helper functions for geometric calculations
# ============================================

def convert_polygon_to_array(polygon):
    """Convert polygon from complex numbers or list to numpy array."""
    if polygon and isinstance(polygon[0], complex):
        return np.array([(p.real, p.imag) for p in polygon])
    return np.array(polygon)

def apply_polygon_inset(polygon_array, offset):
    """Apply inward buffer to polygon using shapely."""
    if offset <= 0:
        return polygon_array
    
    try:
        from shapely.geometry import Polygon
        poly_shapely = Polygon(polygon_array)
        buffered = poly_shapely.buffer(-offset, join_style=2)
        if buffered.is_empty:
            return None
        return np.array(buffered.exterior.coords)
    except:
        return polygon_array

def line_segment_intersection(p1, p2, p3, p4):
    """Calculate intersection point between two line segments.
    
    Returns:
        Tuple (t, x, y) if intersection exists, None otherwise.
        t is the parameter along p1-p2 (0 to 1).
    """
    x1, y1 = p1
    x2, y2 = p2
    x3, y3 = p3
    x4, y4 = p4
    
    denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)
    if abs(denom) < 1e-10:
        return None
    
    t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom
    u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom
    
    if 0 <= t <= 1 and 0 <= u <= 1:
        ix = x1 + t * (x2 - x1)
        iy = y1 + t * (y2 - y1)
        return (t, ix, iy)
    return None

def find_line_polygon_intersections(line_start, line_end, polygon_edges):
    """Find all intersection points between a line and polygon edges.
    
    Returns:
        Sorted list of (t, x, y) tuples where t is parameter along line.
    """
    intersections = []
    for i in range(len(polygon_edges)):
        p3 = polygon_edges[i]
        p4 = polygon_edges[(i + 1) % len(polygon_edges)]
        
        intersection = line_segment_intersection(line_start, line_end, p3, p4)
        if intersection:
            intersections.append(intersection)
    
    return sorted(intersections, key=lambda x: x[0])

def lines_in_polygon(polygon, line_spacing=5, angle=0, color="#000000", stroke_width=0.5, offset=0):
    """Generate parallel lines clipped to polygon bounds.
    
    Args:
        polygon: List of complex numbers or Nx2 array of polygon vertices
        line_spacing: Distance between parallel lines
        angle: Line angle in degrees (0 = horizontal)
        color: Line color (unused, kept for compatibility)
        stroke_width: Line width (unused, kept for compatibility)
        offset: Inward offset from polygon edge in pixels
    
    Returns:
        List of line segment tuples ((x1, y1), (x2, y2))
    """
    polygon_array = convert_polygon_to_array(polygon)
    if polygon_array.shape[0] < 3:
        return []
    
    # Apply inward offset if specified
    polygon_array = apply_polygon_inset(polygon_array, offset)
    if polygon_array is None:
        return []
    
    # Calculate bounding box
    min_x, min_y = polygon_array[:, 0].min(), polygon_array[:, 1].min()
    max_x, max_y = polygon_array[:, 0].max(), polygon_array[:, 1].max()
    bbox_diag = math.hypot(max_x - min_x, max_y - min_y)
    if bbox_diag == 0:
        return []
    
    # Calculate line direction and perpendicular offset direction
    centroid = polygon_array.mean(axis=0)
    theta = math.radians(angle)
    line_dir = np.array([math.cos(theta), math.sin(theta)])
    perp_dir = np.array([-line_dir[1], line_dir[0]])
    
    # Generate parallel lines
    num_lines = int(bbox_diag / max(1e-6, line_spacing)) + 3
    path = MplPath(polygon_array)
    line_segments = []
    
    for i in range(-num_lines, num_lines + 1):
        # Calculate line offset from centroid
        offset_vec = perp_dir * i * line_spacing
        line_start = centroid - line_dir * bbox_diag * 2 + offset_vec
        line_end = centroid + line_dir * bbox_diag * 2 + offset_vec
        
        # Find intersections with polygon
        intersections = find_line_polygon_intersections(line_start, line_end, polygon_array)
        
        # Create segments from intersection pairs
        for j in range(0, len(intersections) - 1, 2):
            _, x1, y1 = intersections[j]
            _, x2, y2 = intersections[j + 1]
            
            # Verify segment is inside polygon
            mid_x, mid_y = (x1 + x2) / 2, (y1 + y2) / 2
            if path.contains_point((mid_x, mid_y)):
                line_segments.append(((x1, y1), (x2, y2)))
    
    return line_segments

# ============================================
# DRAWING CONTEXT
# SVG rendering and coordinate normalization
# ============================================

class DrawingContext:
    """
    Handles SVG drawing and coordinate normalization.

    Manages the SVG drawing object and scales geometric elements to fit within the viewbox.
    """
    def __init__(self, size: int = 800):
        """
        Initializes a DrawingContext.

        Args:
            size: The size of the square drawing area in pixels.
        """
        self.size = size
        self.dwg = svgwrite.Drawing(size=(size, size))
        self.scale_factor = 1.0

    def set_normalization_scale(self, elements: List['CircleElement']):
        """
        Calculates and sets the scale factor to fit elements into the viewbox.

        The scale factor is determined by the maximum extent of the circles (center + radius).

        Args:
            elements: A list of CircleElement objects to consider for scaling.
        """
        if not elements:
            self.scale_factor = 1.0
            self.dwg.viewbox(-self.size/2, -self.size/2, self.size, self.size)
            return

        coords = [c.center for c in elements]
        radii = [c.radius for c in elements]

        # Find the maximum extent including circle radii
        max_extent = max(max(abs(z.real) + r, abs(z.imag) + r) for z, r in zip(coords, radii))

        # Tighter padding: scale such that the max extent fits within 95% of the viewbox half-size
        self.scale_factor = (self.size / 2.1) / max_extent
        # Set the viewbox to center the drawing
        self.dwg.viewbox(-self.size/2, -self.size/2, self.size, self.size)


    def draw_scaled(self, element: Shape, **kwargs):
        """
        Draws a shape element after scaling its coordinates.

        Args:
            element: The Shape element to draw.
            **kwargs: Additional keyword arguments to pass to the element's to_svg method.
        """
        if isinstance(element, CircleElement):
            # Apply scaling to center and radius
            scaled_center = element.center * self.scale_factor
            scaled_radius = element.radius * self.scale_factor
            # Create a temporary scaled element for drawing purposes
            scaled_element = CircleElement(scaled_center, scaled_radius, element.visible)
            svg_element = scaled_element.to_svg(self.dwg, **kwargs)

        elif isinstance(element, ArcElement):
            # Scale the underlying circle and points for the arc
            scaled_circle = CircleElement(
                element.circle.center * self.scale_factor,
                element.circle.radius * self.scale_factor
            )
            # Scale start and end points
            scaled_start = element.start * self.scale_factor
            scaled_end = element.end * self.scale_factor
            # Create a temporary scaled element for drawing purposes
            scaled_element = ArcElement(
                scaled_circle,
                scaled_start,
                scaled_end,
                element.steps,
                element.visible
            )
            svg_element = scaled_element.to_svg(self.dwg, **kwargs)

        else:
            # Unknown element type; skip drawing
            svg_element = None

        if svg_element is not None:
            self.dwg.add(svg_element)

    def make_line_pattern(self, pattern_id="linePattern", spacing=10, angle=45, color="black", stroke_width=1):
        """Create a robust, angle-agnostic parallel line pattern.

        - spacing: distance between lines in user units (pixels)
        - angle: rotation in degrees (0 = vertical lines); positive is CCW
        """
        # Define a square pattern tile in user space; rotate the pattern itself
        pattern = self.dwg.pattern(
            id=pattern_id,
            patternUnits="userSpaceOnUse",
            size=(spacing, spacing),
        )

        # Rotate the pattern so the single vertical line becomes angled globally
        pattern['patternTransform'] = f"rotate({angle})"

        # Draw a vertical line spanning the tile height; duplicate at tile edge to avoid seams
        line_style = {
            'stroke': color,
            'stroke_width': stroke_width,
            'stroke_linecap': 'butt',
        }
        pattern.add(self.dwg.line(start=(0, 0), end=(0, spacing), **line_style))
        # Edge duplicate to mitigate antialiasing gaps at tile boundaries
        pattern.add(self.dwg.line(start=(spacing, 0), end=(spacing, spacing), **line_style))

        # Register pattern in defs
        self.dwg.defs.add(pattern)
        return pattern
    
    def _draw_clipped_line_fill(self, coords, points, stroke, stroke_width, line_pattern_settings, draw_outline, line_offset):
        """Draw polygon with clipped parallel line fill."""
        line_spacing, line_angle = line_pattern_settings
        
        # Generate clipped line segments
        line_segments = lines_in_polygon(
            points, 
            line_spacing=line_spacing, 
            angle=line_angle,
            offset=line_offset
        )
        
        # Optionally draw polygon outline
        if draw_outline:
            self.dwg.add(self.dwg.polygon(
                points=coords, 
                fill="none", 
                stroke=stroke, 
                stroke_width=stroke_width
            ))
        
        # Draw clipped line segments
        line_color = stroke or "#000000"
        for (x1, y1), (x2, y2) in line_segments:
            self.dwg.add(self.dwg.line(
                start=(x1, y1), 
                end=(x2, y2),
                stroke=line_color, 
                stroke_width=0.5
            ))
    
    def draw_group_outline(self, points: List[complex], fill: Optional[str] = None, 
                          stroke: Optional[str] = None, stroke_width: float = 1.0, 
                          line_pattern_settings = (3, 0), use_clipped_lines: bool = False, 
                          draw_outline: bool = True, line_offset: float = 0):
        """Draw a polygon with optional line pattern fill.
        
        Args:
            points: Complex numbers representing polygon vertices
            fill: Fill type ("pattern", "clipped_lines", color, or None)
            stroke: Outline color
            stroke_width: Outline width
            line_pattern_settings: Tuple of (spacing, angle) for line fills
            use_clipped_lines: Use precise clipped lines instead of SVG patterns
            draw_outline: Whether to draw polygon outline
            line_offset: Inward offset for line clipping
        """
        if not points:
            return
        
        coords = [(p.real, p.imag) for p in points]
        
        # Use clipped lines for pattern fills (new method)
        if use_clipped_lines or fill in ("pattern", "clipped_lines"):
            self._draw_clipped_line_fill(
                coords, points, stroke, stroke_width, 
                line_pattern_settings, draw_outline, line_offset
            )
        elif fill is not None:
            # Solid color fill
            self.dwg.add(self.dwg.polygon(
                points=coords, 
                fill=fill, 
                stroke=stroke, 
                stroke_width=stroke_width
            ))
        else:
            # No fill - just outline
            self.dwg.add(self.dwg.polyline(
                points=coords, 
                fill="none", 
                stroke=stroke or "#000000", 
                stroke_width=stroke_width
            ))


    def to_string(self) -> str:
        """
        Returns the SVG drawing as a string.
        """
        return self.dwg.tostring()

class CircleElement(Shape):
    """
    Represents a circle in the geometry, handling intersections.

    Each circle has a unique ID, a center (complex number), and a radius.
    It can compute intersections with other circles and find its neighbours.
    """
    _id_counter = 0

    def __init__(self, center: complex, radius: float, visible: bool = True):
        """
        Initializes a CircleElement.

        Args:
            center: The center of the circle as a complex number.
            radius: The radius of the circle.
            visible: Whether the circle should be visible in the drawing.
        """
        super().__init__(visible)
        CircleElement._id_counter += 1
        self.id = CircleElement._id_counter
        self.center = complex(center)
        self.radius = float(radius)
        # List of (point: complex, other_circle: CircleElement)
        self.intersections: List[Tuple[complex, 'CircleElement']] = []
        self.neighbours: Set['CircleElement'] = set()

    def _get_intersection_points(self, other: 'CircleElement', tol: float = 1e-6) -> List[complex]:
        """
        Calculates the intersection points between this circle and another.

        Uses the Law of Cosines to find the distance from the center to the chord connecting
        the intersection points, then finds the points on the circle along the perpendicular vector.

        Args:
            other: The other CircleElement to intersect with.
            tol: Tolerance for floating point comparisons.

        Returns:
            A list of complex numbers representing the intersection points (0, 1, or 2 points).
        """
        d = abs(self.center - other.center)
        r1, r2 = self.radius, other.radius

        # Check for no intersection, tangency (external or internal), or one circle contained within another
        if d > r1 + r2 + tol or d < abs(r1 - r2) - tol or d < tol:
            return []

        # Distance 'a' from center 1 to the chord connecting intersection points
        a = (r1**2 - r2**2 + d**2) / (2 * d)
        # Half the length of the chord, squared
        h_sq = r1**2 - a**2
        if h_sq < -tol: # Should not happen with checks above, but floating point safety
            return []
        # Half the length of the chord
        h = np.sqrt(max(h_sq, 0))

        # Midpoint of the chord
        mid = self.center + a * (other.center - self.center) / d
        # Vector perpendicular to the line between centers, scaled by 1/d
        perp_unit = 1j * (other.center - self.center) / d

        # The two intersection points
        p1, p2 = mid + h * perp_unit, mid - h * perp_unit

        # If h is near zero, the points are the same (tangency)
        return [p1] if h < tol else [p1, p2]

    def compute_intersections(self, circles: List['CircleElement'], start_reference: Optional[complex] = None, tol: float = 1e-3):
        """
        Computes and sorts intersections sequentially clockwise around the circle.
        The first point is chosen as the one closest to start_reference.

        Args:
            circles: A list of other CircleElement objects to compute intersections with.
            start_reference: A complex number used as a reference point to determine the starting point for sorting.
                             If None, the circle's center is used.
            tol: Tolerance for floating point comparisons when identifying unique points.
        """
        self.intersections.clear()
        self.neighbours.clear()
        seen = set()

        for other in circles:
            if other is self:
                continue
            # Get intersection points with another circle
            pts = self._get_intersection_points(other, tol)
            for p in pts:
                # Use a slightly coarse rounding for deduplication of points
                key = (round(p.real, 6), round(p.imag, 6))
                if key not in seen:
                    self.intersections.append((p, other))
                    seen.add(key)
                    self.neighbours.add(other)

        if not self.intersections:
            return

        c = self.center
        # Default reference point is the circle's center
        if start_reference is None:
            start_reference = c

        # Choose the starting intersection by proximity to the reference point
        start_idx = int(np.argmin([abs(p - start_reference) for p, _ in self.intersections]))
        start_point = self.intersections[start_idx][0]
        start_angle = np.angle(start_point - c)

        def clockwise_offset(angle):
            """Compute clockwise offset from start_angle in [0, 2pi)."""
            # The angle is relative to the center of *this* circle
            offset = (start_angle - angle) % (2 * np.pi)
            return offset

        # Sort intersections by clockwise offset from the starting point
        self.intersections.sort(key=lambda x: clockwise_offset(np.angle(x[0] - c)))

    def get_neighbour_circles(
        self,
        k: Optional[int] = None,
        spiral_center: complex = 0+0j,
        clockwise: bool = True,
        tie_by_distance: bool = True
    ) -> List['CircleElement']:
        """
        Return neighbours sorted by their rotation around `spiral_center` relative to this circle.

        Args:
            k: Optionally limit to the k nearest neighbours (by center distance) BEFORE angular sorting.
            spiral_center: the center of the Doyle spiral (use 0+0j in your code).
            clockwise: if True, returns neighbours in clockwise order around the spiral center
                     starting from this circle's radial direction.
            tie_by_distance: if two neighbours have nearly identical relative angle, break ties using distance.

        Returns:
            A list of neighbour CircleElement objects, sorted according to the specified criteria.
        """
        neighbours = list(self.neighbours)
        if not neighbours:
            return []

        # Optionally keep only k nearest by center distance BEFORE angular ordering:
        if k is not None and len(neighbours) > k:
            neighbours.sort(key=lambda c: abs(c.center - self.center))
            neighbours = neighbours[:k]

        # Precompute base angle of this circle around spiral center
        base_angle = np.angle(self.center - spiral_center)

        def relative_angle_to_base(other: 'CircleElement') -> float:
            # angle of neighbour around spiral center
            a = np.angle(other.center - spiral_center)
            # relative in [0, 2*pi)
            rel = (a - base_angle) % (2 * np.pi)
            return rel

        # Build sort keys: primary = relative angle, secondary = distance (optional)
        if tie_by_distance:
            neighbours.sort(key=lambda c: (relative_angle_to_base(c), abs(c.center - self.center)))
        else:
            neighbours.sort(key=relative_angle_to_base)

        # numpy.angle gives CCW angles increasing; `rel` increases CCW from base direction.
        # If user wants clockwise order, reverse the CCW ordering.
        if clockwise:
            neighbours = list(reversed(neighbours))

        return neighbours


    def to_svg(self, dwg: svgwrite.Drawing, color="#4CB39B", opacity=0.8):
        """
        Renders the circle to an SVG element.

        Args:
            dwg: The svgwrite Drawing object.
            color: The fill color of the circle.
            opacity: The fill opacity of the circle.

        Returns:
            An svgwrite Circle object, or None if the circle is not visible.
        """
        if not self.visible:
            return None
        cx, cy = self.center.real, self.center.imag
        return dwg.circle(center=(cx, cy), r=self.radius, fill=color, fill_opacity=opacity)

class ArcElement(Shape):
    """
    Represents a circular arc segment between two intersection points.

    An arc is defined by the circle it lies on and its start and end points.
    """
    def __init__(self, circle: CircleElement, start: complex, end: complex, steps: int = 40, visible: bool = True):
        """
        Initializes an ArcElement.

        Args:
            circle: The CircleElement the arc lies on.
            start: The starting point of the arc as a complex number.
            end: The ending point of the arc as a complex number.
            steps: The number of discrete points to use for rendering the arc.
            visible: Whether the arc should be visible in the drawing.
        """
        super().__init__(visible)
        self.circle = circle
        self.start = complex(start)
        self.end = complex(end)
        self.steps = steps

    def get_points(self) -> List[complex]:
        """
        Calculates the discrete points defining the arc.

        Calculates the angles of the start and end points relative to the circle's center,
        then generates a sequence of points along the arc.

        Returns:
            A list of complex numbers representing the points along the arc.
        """
        c = self.circle.center
        r = self.circle.radius
        a1 = np.angle(self.start - c)
        a2 = np.angle(self.end - c)

        # Calculate the clockwise angular difference [0, 2pi)
        delta = (a2 - a1 + 2 * np.pi) % (2 * np.pi)

        # Arc is drawn clockwise; use the smaller angular magnitude direction if needed
        if delta > np.pi:
            delta -= 2 * np.pi  # Result in [-2pi, 0] or [-pi, pi] if delta was > pi

        # Generate points along the arc using linspace for angles
        angles = np.linspace(a1, a1 + delta, self.steps)
        return [c + r * np.exp(1j * a) for a in angles]

    def to_svg(self, dwg: svgwrite.Drawing, color="#000000", width=1.2):
        """
        Renders the arc to an SVG element.

        Args:
            dwg: The svgwrite Drawing object.
            color: The stroke color of the arc.
            width: The stroke width of the arc.

        Returns:
            An svgwrite Path object representing the arc, or None if the arc is not visible.
        """
        if not self.visible:
            return None
        # Get the discrete points for the arc
        pts = self.get_points()
        if not pts:
            return None
        # Create a path string from the points
        path_data = ["M", f"{pts[0].real},{pts[0].imag}"] + [f"L{p.real},{p.imag}" for p in pts[1:]]
        return dwg.path(d=" ".join(path_data), fill="none", stroke=color, stroke_width=width)

# ============================================
# ARC GROUP
# Groups of arcs for outline rendering
# ============================================

class ArcGroup:
    """
    Group of ArcElement objects.

    - An ArcElement can belong to multiple ArcGroups (we store references).
    - We can attempt to produce a closed outline from the group's arcs.
    """
    _id_counter = 0

    def __init__(self, name: Optional[str] = None):
        """
        Initializes an ArcGroup.

        Args:
            name: An optional name for the group.
        """
        ArcGroup._id_counter += 1
        self.id = ArcGroup._id_counter
        self.name = name or f"arcgroup_{self.id}"
        self.arcs: List[ArcElement] = []
        # color for debug visualization
        self.debug_fill: Optional[str] = None
        self.debug_stroke: Optional[str] = None
        # public: ring layer index within the Doyle spiral (0-based from smallest radius)
        self.ring_index: Optional[int] = None

    def add_arc(self, arc: ArcElement):
        """
        Adds an ArcElement to the group.

        Args:
            arc: The ArcElement to add.
        """
        self.arcs.append(arc)

    def extend(self, arcs: List[ArcElement]):
        """
        Adds multiple ArcElement objects to the group.

        Args:
            arcs: A list of ArcElement objects to add.
        """
        self.arcs.extend(arcs)

    def clear(self):
        """
        Removes all arcs from the group.
        """
        self.arcs.clear()

    def is_empty(self) -> bool:
        """
        Checks if the group is empty.

        Returns:
            True if the group contains no arcs, False otherwise.
        """
        return len(self.arcs) == 0

    def get_all_points(self) -> List[complex]:
        """
        Return concatenation of point sequences from all arcs (in their stored order).

        Returns:
            A list of complex numbers representing all points from all arcs in the group.
        """
        pts = []
        for arc in self.arcs:
            pts.extend(arc.get_points())
        return pts

    def _match_points(self, a: complex, b: complex, tol: float = 1e-6) -> bool:
        """
        Checks if two points are approximately the same within a given tolerance.

        Args:
            a: The first point (complex number).
            b: The second point (complex number).
            tol: The tolerance for comparison.

        Returns:
            True if the points are within the tolerance, False otherwise.
        """
        return abs(a - b) <= tol


    def _try_attach_arc(self, ordered_pts, pts, tol):
        """Try to attach arc points to the ordered outline.
        
        Returns:
            Modified ordered_pts if attachment successful, None otherwise.
        """
        start_existing = ordered_pts[0]
        end_existing = ordered_pts[-1]
        start_arc = pts[0]
        end_arc = pts[-1]
        
        # Try appending arc (original direction)
        if self._match_points(end_existing, start_arc, tol):
            return ordered_pts + pts[1:]
        
        # Try appending arc (reversed)
        if self._match_points(end_existing, end_arc, tol):
            return ordered_pts + list(reversed(pts))[1:]
        
        # Try prepending arc (original direction)
        if self._match_points(start_existing, end_arc, tol):
            return pts[:-1] + ordered_pts
        
        # Try prepending arc (reversed)
        if self._match_points(start_existing, start_arc, tol):
            return list(reversed(pts))[:-1] + ordered_pts
        
        return None
    
    def _attach_by_proximity(self, ordered_pts, pts):
        """Attach arc to outline by nearest endpoint."""
        # Calculate distances to front and back of outline
        d_front = min(abs(pts[0] - ordered_pts[0]), abs(pts[-1] - ordered_pts[0]))
        d_back = min(abs(pts[0] - ordered_pts[-1]), abs(pts[-1] - ordered_pts[-1]))
        
        if d_front < d_back:
            # Attach to front
            if abs(pts[-1] - ordered_pts[0]) <= abs(pts[0] - ordered_pts[0]):
                return pts[:-1] + ordered_pts
            else:
                return list(reversed(pts))[:-1] + ordered_pts
        else:
            # Attach to back
            if abs(pts[0] - ordered_pts[-1]) <= abs(pts[-1] - ordered_pts[-1]):
                return ordered_pts + pts[1:]
            else:
                return ordered_pts + list(reversed(pts))[1:]
    
    def get_closed_outline(self, tol: float = 1e-3) -> List[complex]:
        """Order arcs into a closed outline.
        
        Attempts to chain arcs by matching endpoints, reversing when needed.
        Falls back to proximity-based attachment for remaining arcs.
        
        Returns:
            List of points forming the outline (closed if endpoints match).
        """
        if not self.arcs:
            return []
        
        # Prepare arc entries sorted by point count (longest first)
        entries = [(arc, arc.get_points()) for arc in self.arcs]
        entries.sort(key=lambda e: -len(e[1]))
        
        # Start with longest arc
        ordered_pts = entries[0][1].copy()
        used = {0}
        
        # Greedily attach arcs that match endpoints
        while True:
            attached_any = False
            for idx, (arc, pts) in enumerate(entries):
                if idx in used:
                    continue
                
                result = self._try_attach_arc(ordered_pts, pts, tol)
                if result is not None:
                    ordered_pts = result
                    used.add(idx)
                    attached_any = True
                    break
            
            if not attached_any:
                break
        
        # Attach remaining arcs by proximity
        for idx in range(len(entries)):
            if idx not in used:
                ordered_pts = self._attach_by_proximity(ordered_pts, entries[idx][1])
        
        # Close the outline if endpoints match
        if ordered_pts and abs(ordered_pts[0] - ordered_pts[-1]) <= tol:
            ordered_pts[-1] = ordered_pts[0]
        
        return ordered_pts

    def to_svg_fill(self, context: DrawingContext, debug: bool = False, fill_opacity: float = 0.25, pattern_fill: bool = False, line_settings = (2,0), use_clipped_lines: bool = True, draw_outline: bool = True, line_offset: float = 0):
        """
        Render group outline as filled polygon if closed (or as polyline) for debug.

        The context expects unscaled points; we will scale them with context.scale_factor.

        Args:
            context: The DrawingContext to use for rendering.
            debug: Whether to render with debug colors (fill and stroke).
            fill_opacity: The opacity of the fill when debug is True.
            pattern_fill: Whether to use pattern/line fill.
            line_settings: Tuple of (spacing, angle) for line patterns.
            use_clipped_lines: If True, use actual clipped lines instead of SVG patterns (default: True).
            draw_outline: If True, draw the polygon outline (default: True).
            line_offset: Inset distance from polygon edge for line clipping (positive = shrink inward).
        """
        # Get the points for the outline
        pts = self.get_closed_outline()
        if not pts:
            return
        # scale points using the drawing context's scale factor
        scaled = [p * context.scale_factor for p in pts]
        if debug:
            # Generate a random color if debug colors are not set
            fill = self.debug_fill or "#%06x" % random.randint(0, 0xFFFFFF)
            stroke = self.debug_stroke or "#000000"
            # set fill and stroke and draw as a polygon
            context.draw_group_outline(scaled, fill=fill, stroke=stroke, stroke_width=0.8)
        elif pattern_fill:
            stroke = self.debug_stroke or "#000000"
            context.draw_group_outline(scaled, fill="pattern", stroke=stroke, stroke_width=0.8, 
                                      line_pattern_settings=line_settings, use_clipped_lines=use_clipped_lines,
                                      draw_outline=draw_outline, line_offset=line_offset)
        else:
            # Only draw outline if draw_outline is explicitly True when pattern_fill is False
            if draw_outline:
                context.draw_group_outline(scaled, fill=None, stroke="#000000", stroke_width=0.6)

# ============================================
# Doyle Spiral Class
# ============================================

